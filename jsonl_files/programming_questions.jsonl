{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the result of the following code?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Base:\n    def method(self):\n        print('Base method')\n\nclass Derived(Base):\n    def method(self):\n        print('Derived method')\n        super().method()\n\nobj = Derived()\nobj.method()</code></pre></div>", "options": {"A": "Base method", "B": "Derived method", "C": "Derived method\nBase method", "D": "Base method\nDerived method"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the output of the following code?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class A:\n    def __init__(self):\n        self.x = 1\n\nclass B(A):\n    def __init__(self):\n        super().__init__()\n        self.x = 2\n\nclass C(A):\n    def __init__(self):\n        super().__init__()\n        self.x = 3\n\nclass D(B, C):\n    def __init__(self):\n        super().__init__()\n\nobj = D()\nprint(obj.x)</code></pre></div>", "options": {"A": "1", "B": "2", "C": "3", "D": "Error"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What will be the output of the following code?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def make_incrementor(n):\n    return lambda x: x + n\n\nf = make_incrementor(42)\nprint(f(0))\nprint(f(1))</code></pre></div>", "options": {"A": "0\n1", "B": "42\n43", "C": "Error", "D": "None of the above"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is a valid use of decorators in Python?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def decorator_function(original_function):\n    def wrapper_function():\n        print('Wrapper executed this before {}'.format(original_function.__name__))\n        return original_function()\n    return wrapper_function\n\n@decorator_function\ndef display():\n    print('Display function ran')\n\ndisplay()</code></pre></div>", "options": {"A": "Wrapper executed this before display\nDisplay function ran", "B": "Display function ran\nWrapper executed this before display", "C": "Display function ran", "D": "Wrapper executed this before display"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the output of the following code?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def extendList(val, list=[]):\n    list.append(val)\n    return list\n\nlist1 = extendList(10)\nlist2 = extendList(123,[])\nlist3 = extendList('a')\nprint('list1: %s' % list1)\nprint('list2: %s' % list2)\nprint('list3: %s' % list3)</code></pre></div>", "options": {"A": "list1: [10, 'a']\nlist2: [123]\nlist3: ['a']", "B": "list1: [10]\nlist2: [123]\nlist3: ['a']", "C": "list1: [10, 'a']\nlist2: [10, 123, 'a']\nlist3: [10, 'a']", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def foo(val, lst=[]):\n    lst.append(val)\n    return lst\n\nlist1 = foo(10)\nlist2 = foo(123, [])\nlist3 = foo('a')\nprint(list1)\nprint(list2)\nprint(list3)</code></pre></div>", "options": {"A": "[10, 'a']\n[123]\n['a']", "B": "[10]\n[123]\n['a']", "C": "[10, 'a']\n[10, 123, 'a']\n['a']", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `yield` keyword in Python?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def generator_example():\n    yield 1\n    yield 2\n    yield 3\n\nfor value in generator_example():\n    print(value)</code></pre></div>", "options": {"A": "It returns a value and terminates the function", "B": "It returns a value and pauses the function", "C": "It creates a generator object", "D": "Both B and C"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Foo:\n    def __init__(self, x=0):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Bar(Foo):\n    def __init__(self, x=0, y=0):\n        super().__init__(x)\n        self.y = y\n    def __str__(self):\n        return super().__str__() + str(self.y)\n\nbar = Bar(1, 2)\nprint(bar)</code></pre></div>", "options": {"A": "12", "B": "1 2", "C": "2", "D": "1"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements are true regarding Python's `with` statement?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>with open('file.txt', 'w') as f:\n    f.write('Hello, world!')</code></pre></div>", "options": {"A": "The `with` statement simplifies exception handling", "B": "The `with` statement ensures proper acquisition and release of resources", "C": "The `with` statement can only be used with file objects", "D": "Both A and B"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def myfunc(*args, **kwargs):\n    print(args)\n    print(kwargs)\n\nmyfunc(1, 2, 3, a='A', b='B')</code></pre></div>", "options": {"A": "(1, 2, 3)\n{'a': 'A', 'b': 'B'}", "B": "([1, 2, 3], {'a': 'A', 'b': 'B'})", "C": "[1, 2, 3]\n{'a': 'A', 'b': 'B'}", "D": "(1, 2, 3)\n{'a': 'A', 'b': 'B'}"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "Which of the following statements about Python's garbage collection is true?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import gc\n\nclass MyClass:\n    def __del__(self):\n        print('Instance deleted')\n\nobj = MyClass()\ndel obj\ngc.collect()</code></pre></div>", "options": {"A": "Python uses reference counting for memory management", "B": "Python has a cyclic garbage collector to handle reference cycles", "C": "Objects with `__del__` methods may not be collected immediately", "D": "All of the above"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What will be the output of the following code?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def outer(x):\n    def inner(y):\n        return x + y\n    return inner\n\nf = outer(10)\nprint(f(5))</code></pre></div>", "options": {"A": "15", "B": "10", "C": "5", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the result of the following code involving the `map` function?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def square(x):\n    return x * x\n\nresult = map(square, [1, 2, 3, 4, 5])\nprint(list(result))</code></pre></div>", "options": {"A": "[1, 4, 9, 16, 25]", "B": "[1, 2, 3, 4, 5]", "C": "[2, 4, 6, 8, 10]", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving list comprehensions?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>result = [x * y for x in range(3) for y in range(3)]\nprint(result)</code></pre></div>", "options": {"A": "[0, 0, 0, 0, 1, 2, 0, 2, 4]", "B": "[0, 1, 2, 0, 1, 2, 0, 1, 2]", "C": "[0, 1, 2, 0, 2, 4, 0, 3, 6]", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `set` data type?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>my_set = {1, 2, 3, 4}\nmy_set.add(5)\nprint(my_set)</code></pre></div>", "options": {"A": "Sets can contain duplicate elements", "B": "Sets are mutable", "C": "Sets maintain the order of elements", "D": "None of the above"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving metaclasses?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Meta(type):\n    def __new__(cls, name, bases, dct):\n        dct['id'] = 'meta'\n        return super().__new__(cls, name, bases, dct)\n\nclass Base(metaclass=Meta):\n    pass\n\nclass Derived(Base):\n    pass\n\nprint(Derived.id)</code></pre></div>", "options": {"A": "meta", "B": "base", "C": "derived", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of Python's `__init__.py` file in a package?\n\n<div style='border:1px solid black; padding:10px;'><pre><code># Directory structure\n# mypackage/\n# \u251c\u2500\u2500 __init__.py\n# \u251c\u2500\u2500 module1.py\n# \u2514\u2500\u2500 module2.py</code></pre></div>", "options": {"A": "It makes the directory a package", "B": "It initializes the package", "C": "It contains the package's metadata", "D": "Both A and B"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "Which of the following code snippets correctly implements a context manager using a class?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyContextManager:\n    def __enter__(self):\n        print('Enter context')\n        return self\n    def __exit__(self, exc_type, exc_value, traceback):\n        print('Exit context')\n\nwith MyContextManager() as manager:\n    print('Inside context')</code></pre></div>", "options": {"A": "Enter context\nInside context\nExit context", "B": "Inside context\nEnter context\nExit context", "C": "Enter context\nExit context\nInside context", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the output of the following code involving class methods and instance methods?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def instance_method(self):\n        return 'instance method called', self\n    @classmethod\n    def class_method(cls):\n        return 'class method called', cls\n    @staticmethod\n    def static_method():\n        return 'static method called'\n\nobj = MyClass()\nprint(obj.instance_method())\nprint(obj.class_method())\nprint(obj.static_method())</code></pre></div>", "options": {"A": "('instance method called', <__main__.MyClass object at 0x...>)\n('class method called', <class '__main__.MyClass'>)\n'static method called'", "B": "('instance method called', <__main__.MyClass object at 0x...>)\n'class method called'\n'static method called'", "C": "'instance method called'\n'class method called'\n'static method called'", "D": "('instance method called', <__main__.MyClass object at 0x...>)\n<class method called>\n'static method called'"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What will be the output of the following code involving `collections.Counter`?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from collections import Counter\n\ncounter = Counter(['a', 'b', 'c', 'a', 'b', 'a'])\nprint(counter.most_common(1))</code></pre></div>", "options": {"A": "[('a', 3)]", "B": "[('a', 2)]", "C": "[('b', 2)]", "D": "[('c', 1)]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the output of the following code involving property decorators?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Celsius:\n    def __init__(self, temperature=0):\n        self._temperature = temperature\n\n    def to_fahrenheit(self):\n        return (self.temperature * 1.8) + 32\n\n    @property\n    def temperature(self):\n        return self._temperature\n\n    @temperature.setter\n    def temperature(self, value):\n        if value < -273.15:\n            raise ValueError('Temperature below -273.15 is not possible')\n        self._temperature = value\n\nc = Celsius(25)\nprint(c.temperature)\nc.temperature = -300</code></pre></div>", "options": {"A": "25\nValueError", "B": "25\n-300", "C": "Error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What will be the output of the following code involving list slicing?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>my_list = [1, 2, 3, 4, 5]\nprint(my_list[2:])\nprint(my_list[:2])\nprint(my_list[::2])</code></pre></div>", "options": {"A": "[3, 4, 5]\n[1, 2]\n[1, 3, 5]", "B": "[2, 3, 4, 5]\n[1]\n[1, 2, 3, 4, 5]", "C": "[3, 4, 5]\n[1]\n[1, 3, 5]", "D": "[2, 3, 4, 5]\n[1, 2]\n[1, 2, 3, 4, 5]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "Which of the following is true about Python's `abc` module?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from abc import ABC, abstractmethod\n\nclass MyAbstractClass(ABC):\n    @abstractmethod\n    def my_method(self):\n        pass\n\nclass MyConcreteClass(MyAbstractClass):\n    def my_method(self):\n        print('Implemented method')</code></pre></div>", "options": {"A": "You can instantiate an abstract class directly", "B": "You cannot instantiate an abstract class directly", "C": "Abstract classes can have implemented methods", "D": "Both B and C"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving decorators?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def my_decorator(func):\n    def wrapper():\n        print('Something is happening before the function is called.')\n        func()\n        print('Something is happening after the function is called.')\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print('Hello!')\n\nsay_hello()</code></pre></div>", "options": {"A": "Hello!", "B": "Something is happening before the function is called.\nHello!", "C": "Something is happening before the function is called.\nHello!\nSomething is happening after the function is called.", "D": "Hello!\nSomething is happening after the function is called."}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements is true about Python's exception handling?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>try:\n    x = 1 / 0\nexcept ZeroDivisionError:\n    print('Cannot divide by zero')\nelse:\n    print('Division successful')\nfinally:\n    print('This will always execute')</code></pre></div>", "options": {"A": "The `else` block executes if the `try` block raises an exception", "B": "The `finally` block executes only if the `try` block does not raise an exception", "C": "The `finally` block always executes regardless of exceptions", "D": "Both A and C"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving `@classmethod` and `@staticmethod`?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def instance_method(self):\n        return 'instance method called', self\n    @classmethod\n    def class_method(cls):\n        return 'class method called', cls\n    @staticmethod\n    def static_method():\n        return 'static method called'\n\nprint(MyClass.class_method())\nprint(MyClass.static_method())</code></pre></div>", "options": {"A": "('class method called', <class '__main__.MyClass'>)\n'static method called'", "B": "'class method called'\n'static method called'", "C": "('class method called', <class '__main__.MyClass'>)\n('static method called',)", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements about Python's `__init__` method is true?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def __init__(self, value):\n        self.value = value</code></pre></div>", "options": {"A": "The `__init__` method is called when an instance of the class is created", "B": "The `__init__` method is called when an instance of the class is deleted", "C": "The `__init__` method must return a value", "D": "The `__init__` method can be called multiple times on the same instance"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving nested functions and scopes?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def outer_function():\n    x = 'Hello'\n    def inner_function():\n        nonlocal x\n        x = 'World'\n        print(x)\n    inner_function()\n    print(x)\n\nouter_function()</code></pre></div>", "options": {"A": "World\nHello", "B": "Hello\nWorld", "C": "World\nWorld", "D": "Hello\nHello"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements about Python's `__str__` method is true?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def __str__(self):\n        return 'Hello, World!'\n\nobj = MyClass()\nprint(obj)</code></pre></div>", "options": {"A": "The `__str__` method is used to create a string representation of an object", "B": "The `__str__` method is used to create a machine-readable representation of an object", "C": "The `__str__` method must be called explicitly", "D": "The `__str__` method cannot be overridden"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the output of the following code involving class and instance attributes?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    class_attr = 'class'\n    def __init__(self):\n        self.instance_attr = 'instance'\n\nobj = MyClass()\nprint(obj.class_attr)\nprint(obj.instance_attr)</code></pre></div>", "options": {"A": "class\ninstance", "B": "instance\nclass", "C": "Error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "Which of the following statements about Python's `super()` function is true?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class A:\n    def method(self):\n        print('A method')\n\nclass B(A):\n    def method(self):\n        print('B method')\n        super().method()\n\nobj = B()\nobj.method()</code></pre></div>", "options": {"A": "The `super()` function calls the method from the superclass", "B": "The `super()` function calls the method from the subclass", "C": "The `super()` function must be called explicitly", "D": "The `super()` function cannot be used in multiple inheritance"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@staticmethod` decorator in Python?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    @staticmethod\n    def my_static_method():\n        print('This is a static method')</code></pre></div>", "options": {"A": "It defines a method that does not operate on an instance or class", "B": "It defines a method that operates on an instance", "C": "It defines a method that operates on a class", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving `__slots__`?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    __slots__ = ['attr']\n    def __init__(self, value):\n        self.attr = value\n\nobj = MyClass(10)\nprint(obj.attr)\nobj.new_attr = 20</code></pre></div>", "options": {"A": "10\n20", "B": "10\nError", "C": "Error", "D": "None of the above"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the result of the following code involving dictionary comprehensions?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>my_dict = {x: x*x for x in range(5)}\nprint(my_dict)</code></pre></div>", "options": {"A": "{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}", "B": "{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}", "C": "{0: 0, 1: 1, 2: 2, 3: 3, 4: 4}", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the output of the following code involving tuple unpacking?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>a, b, c = 1, 2, 3\nprint(a)\nprint(b)\nprint(c)</code></pre></div>", "options": {"A": "1\n2\n3", "B": "1\n3\n2", "C": "Error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the output of the following code involving the `reduce` function?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from functools import reduce\n\ndef add(x, y):\n    return x + y\n\nresult = reduce(add, [1, 2, 3, 4, 5])\nprint(result)</code></pre></div>", "options": {"A": "15", "B": "10", "C": "20", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the output of the following code involving function annotations?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def my_function(a: int, b: int) -> int:\n    return a + b\n\nprint(my_function(1, 2))\nprint(my_function.__annotations__)</code></pre></div>", "options": {"A": "3\n{'a': <class 'int'>, 'b': <class 'int'>, 'return': <class 'int'>}", "B": "3\n{}", "C": "Error", "D": "3\nNone"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the `@property` decorator?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def __init__(self, value):\n        self._value = value\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, new_value):\n        self._value = new_value\n\nobj = MyClass(10)\nprint(obj.value)\nobj.value = 20\nprint(obj.value)</code></pre></div>", "options": {"A": "10\n20", "B": "10\nError", "C": "Error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `assert` statement?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>x = 10\nassert x > 5, 'x is not greater than 5'\nassert x < 5, 'x is not less than 5'</code></pre></div>", "options": {"A": "The first assert statement will raise an AssertionError", "B": "The second assert statement will raise an AssertionError", "C": "Both assert statements will pass without error", "D": "Both assert statements will raise an AssertionError"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the output of the following code involving the `@classmethod` decorator?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    @classmethod\n    def my_class_method(cls):\n        return 'class method called', cls\n\nobj = MyClass()\nprint(obj.my_class_method())</code></pre></div>", "options": {"A": "('class method called', <class '__main__.MyClass'>)", "B": "'class method called'", "C": "Error", "D": "('class method called', <__main__.MyClass object at 0x...>)"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What will be the output of the following code involving list comprehensions?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>result = [x for x in range(10) if x % 2 == 0]\nprint(result)</code></pre></div>", "options": {"A": "[0, 2, 4, 6, 8]", "B": "[1, 3, 5, 7, 9]", "C": "[2, 4, 6, 8, 10]", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving class attributes and instance attributes?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    class_attr = 'class'\n    def __init__(self):\n        self.instance_attr = 'instance'\n\nobj = MyClass()\nprint(obj.class_attr)\nprint(obj.instance_attr)</code></pre></div>", "options": {"A": "class\ninstance", "B": "instance\nclass", "C": "Error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the output of the following code involving set operations?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>set1 = {1, 2, 3}\nset2 = {3, 4, 5}\nprint(set1 & set2)\nprint(set1 | set2)</code></pre></div>", "options": {"A": "{3}\n{1, 2, 3, 4, 5}", "B": "{1, 2}\n{1, 2, 3}", "C": "{3}\n{3, 4, 5}", "D": "{1, 2}\n{4, 5}"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "Which of the following is true about Python's `__new__` method?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def __new__(cls, *args, **kwargs):\n        instance = super().__new__(cls)\n        return instance\n    def __init__(self, value):\n        self.value = value</code></pre></div>", "options": {"A": "The `__new__` method is responsible for creating a new instance", "B": "The `__new__` method is called after `__init__`", "C": "The `__new__` method cannot be overridden", "D": "The `__new__` method initializes the instance attributes"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of Python's `itertools` module?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import itertools\n\nfor item in itertools.product([1, 2], ['a', 'b']):\n    print(item)</code></pre></div>", "options": {"A": "It provides functions for efficient looping", "B": "It provides functions for creating iterators for efficient looping", "C": "It provides functions for string manipulation", "D": "It provides functions for mathematical operations"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements is true about Python's `sys` module?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import sys\n\nprint(sys.version)</code></pre></div>", "options": {"A": "The `sys` module provides access to some variables used or maintained by the Python interpreter", "B": "The `sys` module provides functions for interacting with the operating system", "C": "The `sys` module provides functions for working with dates and times", "D": "The `sys` module provides functions for working with regular expressions"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What will be the output of the following code involving list methods?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>my_list = [1, 2, 3]\nmy_list.extend([4, 5])\nprint(my_list)\nmy_list.insert(2, 'a')\nprint(my_list)</code></pre></div>", "options": {"A": "[1, 2, 3, 4, 5]\n[1, 2, 'a', 3, 4, 5]", "B": "[1, 2, 3, 4, 5]\n[1, 2, 3, 'a', 4, 5]", "C": "[1, 2, 3, 4, 5]\n['a', 1, 2, 3, 4, 5]", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "Which of the following statements about Python's `__del__` method is true?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def __del__(self):\n        print('Instance deleted')</code></pre></div>", "options": {"A": "The `__del__` method is called when an instance is created", "B": "The `__del__` method is called when an instance is garbage collected", "C": "The `__del__` method cannot be defined in a class", "D": "The `__del__` method must be called explicitly"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving recursive functions?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(5))</code></pre></div>", "options": {"A": "120", "B": "24", "C": "6", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following algorithms is used in the Timsort algorithm?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def timsort(arr):\n    # Implementation of Timsort algorithm\n    pass</code></pre></div>", "options": {"A": "Merge Sort and Insertion Sort", "B": "Quick Sort and Insertion Sort", "C": "Heap Sort and Merge Sort", "D": "Bubble Sort and Quick Sort"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving graph traversal?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>graph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F'],\n    'D': [],\n    'E': ['F'],\n    'F': []\n}\n\nvisited = set()\n\ndef dfs(node):\n    if node not in visited:\n        print(node)\n        visited.add(node)\n        for neighbour in graph[node]:\n            dfs(neighbour)\n\ndfs('A')</code></pre></div>", "options": {"A": "A B D E F C", "B": "A B C D E F", "C": "A C F B D E", "D": "A B E D F C"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of inserting an element at the end of a Python list?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(log n)", "D": "O(n log n)"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for calculating Fibonacci numbers?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def fibonacci(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 2:\n        return 1\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]\n\nprint(fibonacci(10))</code></pre></div>", "options": {"A": "55", "B": "89", "C": "144", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the best-case time complexity of the Quick Sort algorithm?", "options": {"A": "O(n^2)", "B": "O(n log n)", "C": "O(log n)", "D": "O(n)"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a priority queue?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import heapq\n\npq = []\nheapq.heappush(pq, (3, 'C'))\nheapq.heappush(pq, (1, 'A'))\nheapq.heappush(pq, (2, 'B'))\nheapq.heappush(pq, (4, 'D'))\n\nwhile pq:\n    print(heapq.heappop(pq)[1])</code></pre></div>", "options": {"A": "A B C D", "B": "D C B A", "C": "A B D C", "D": "C B A D"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following data structures is used in Breadth-First Search (BFS)?", "options": {"A": "Stack", "B": "Queue", "C": "Heap", "D": "Tree"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the result of the following code involving a linked list?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=' ')\n            current = current.next\n\nllist = LinkedList()\nllist.append(1)\nllist.append(2)\nllist.append(3)\nllist.print_list()</code></pre></div>", "options": {"A": "1 2 3", "B": "3 2 1", "C": "1 3 2", "D": "2 1 3"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving binary search?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def binary_search(arr, x):\n    l, r = 0, len(arr) - 1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return -1\n\narr = [2, 3, 4, 10, 40]\nx = 10\nprint(binary_search(arr, x))</code></pre></div>", "options": {"A": "3", "B": "4", "C": "2", "D": "1"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a bug with variable scopes?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def func():\n    x = 10\n    def inner():\n        print(x)\n        x = 20\n    inner()\n\nfunc()</code></pre></div>", "options": {"A": "10", "B": "20", "C": "UnboundLocalError", "D": "None of the above"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following sorting algorithms is not stable?", "options": {"A": "Merge Sort", "B": "Quick Sort", "C": "Bubble Sort", "D": "Insertion Sort"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a circular linked list?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            new_node.next = self.head\n            return\n        temp = self.head\n        while temp.next != self.head:\n            temp = temp.next\n        temp.next = new_node\n        new_node.next = self.head\n\n    def print_list(self):\n        current = self.head\n        while True:\n            print(current.data, end=' ')\n            current = current.next\n            if current == self.head:\n                break\n\ncllist = CircularLinkedList()\ncllist.append(1)\ncllist.append(2)\ncllist.append(3)\ncllist.print_list()</code></pre></div>", "options": {"A": "1 2 3", "B": "3 2 1", "C": "1 3 2", "D": "2 1 3"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of searching for an element in a balanced binary search tree (BST)?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(log n)", "D": "O(n log n)"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a deque (double-ended queue)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from collections import deque\n\ndq = deque()\ndq.append(1)\ndq.append(2)\ndq.appendleft(3)\ndq.appendleft(4)\nprint(dq)</code></pre></div>", "options": {"A": "deque([4, 3, 1, 2])", "B": "deque([1, 2, 3, 4])", "C": "deque([3, 4, 1, 2])", "D": "deque([2, 1, 4, 3])"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `heapq` module?", "options": {"A": "It provides an implementation of the heap queue algorithm", "B": "It provides an implementation of a binary search algorithm", "C": "It provides functions for working with linked lists", "D": "It provides functions for working with balanced trees"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the result of the following code involving dynamic programming for the Longest Common Subsequence (LCS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lcs(X, Y):\n    m = len(X)\n    n = len(Y)\n    L = [[0] * (n + 1) for i in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n\n    return L[m][n]\n\nX = "AGGTAB"\nY = "GXTXAYB"\nprint(lcs(X, Y))</code></pre></div>", "options": {"A": "4", "B": "5", "C": "6", "D": "7"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following data structures is used in Depth-First Search (DFS)?", "options": {"A": "Stack", "B": "Queue", "C": "Heap", "D": "Tree"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the result of the following code involving an adjacency list for representing a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_edge(self, u, v):\n        if u not in self.graph:\n            self.graph[u] = []\n        self.graph[u].append(v)\n\n    def print_graph(self):\n        for node in self.graph:\n            print(node, '->', ' -> '.join([str(i) for i in self.graph[node]]))\n\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 4)\ng.add_edge(1, 2)\ng.add_edge(1, 3)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(3, 4)\ng.print_graph()</code></pre></div>", "options": {"A": "0 -> 1 -> 4\n1 -> 2 -> 3 -> 4\n2 -> 3\n3 -> 4", "B": "0 -> 1 -> 2 -> 3 -> 4\n1 -> 2 -> 3 -> 4\n2 -> 3 -> 4\n3 -> 4 -> 0", "C": "0 -> 1 -> 4\n1 -> 3 -> 4\n2 -> 3\n3 -> 0 -> 1", "D": "0 -> 1 -> 2 -> 3 -> 4\n1 -> 3 -> 4\n2 -> 4\n3 -> 0 -> 1"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving trie data structure?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\ntrie = Trie()\ntrie.insert("hello")\ntrie.insert("hell")\ntrie.insert("he")\nprint(trie.search("hell"))\nprint(trie.search("hello"))\nprint(trie.search("heaven"))</code></pre></div>", "options": {"A": "True, True, False", "B": "False, True, False", "C": "True, False, True", "D": "False, False, True"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a binary tree traversal?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef print_inorder(root):\n    if root:\n        print_inorder(root.left)\n        print(root.val),\n        print_inorder(root.right)\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nprint_inorder(root)</code></pre></div>", "options": {"A": "4 2 5 1 3", "B": "1 2 3 4 5", "C": "4 5 2 1 3", "D": "1 4 2 5 3"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is a correct implementation of a binary search algorithm?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def binary_search(arr, x):\n    l, r = 0, len(arr) - 1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return -1</code></pre></div>", "options": {"A": "Correct implementation", "B": "Incorrect implementation", "C": "Syntax error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a graph representation using an adjacency matrix?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]\n\n    def add_edge(self, src, dest):\n        self.graph[src][dest] = 1\n\n    def print_graph(self):\n        for row in self.graph:\n            print(" ".join(map(str, row)))\n\nvertices = 4\ng = Graph(vertices)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\ng.print_graph()</code></pre></div>", "options": {"A": "0 1 1 0\n0 0 1 0\n1 0 0 1\n0 0 0 1", "B": "1 0 0 1\n0 1 1 0\n1 0 0 1\n0 0 0 0", "C": "0 1 0 1\n1 0 1 0\n1 1 0 1\n0 0 0 1", "D": "1 0 0 1\n0 1 1 0\n1 0 0 0\n0 1 0 1"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `__init__.py` file in a Python package?", "options": {"A": "It initializes the package", "B": "It defines the package's metadata", "C": "It makes the directory a package", "D": "Both A and C"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the result of the following code involving a doubly linked list?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n        new_node.prev = last\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=' ')\n            current = current.next\n\nllist = DoublyLinkedList()\nllist.append(1)\nllist.append(2)\nllist.append(3)\nllist.print_list()</code></pre></div>", "options": {"A": "1 2 3", "B": "3 2 1", "C": "1 3 2", "D": "2 1 3"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a balanced binary search tree (BST)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insert(root, key):\n    if root is None:\n        return TreeNode(key)\n    else:\n        if root.val < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n\ndef inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.val)\n        inorder(root.right)\n\nroot = TreeNode(50)\nroot = insert(root, 30)\nroot = insert(root, 20)\nroot = insert(root, 40)\nroot = insert(root, 70)\nroot = insert(root, 60)\nroot = insert(root, 80)\ninorder(root)</code></pre></div>", "options": {"A": "20 30 40 50 60 70 80", "B": "50 30 20 40 70 60 80", "C": "80 70 60 50 40 30 20", "D": "20 40 30 60 80 70 50"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `deque` data structure from the `collections` module?", "options": {"A": "It is implemented as a doubly linked list", "B": "It supports O(1) operations for append and pop", "C": "It can be used as both a queue and a stack", "D": "All of the above"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `functools` module in Python?", "options": {"A": "It provides higher-order functions", "B": "It provides functions for functional programming", "C": "It provides decorators to manipulate or extend the behavior of functions", "D": "All of the above"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving memoization for calculating the factorial of a number?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def factorial(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 1\n    else:\n        memo[n] = n * factorial(n-1, memo)\n        return memo[n]\n\nprint(factorial(5))</code></pre></div>", "options": {"A": "120", "B": "24", "C": "6", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a heap data structure?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import heapq\n\nheap = []\nheapq.heappush(heap, 10)\nheapq.heappush(heap, 20)\nheapq.heappush(heap, 5)\nheapq.heappush(heap, 15)\nprint([heapq.heappop(heap) for _ in range(len(heap))])</code></pre></div>", "options": {"A": "[5, 10, 15, 20]", "B": "[10, 5, 15, 20]", "C": "[5, 15, 10, 20]", "D": "[20, 15, 10, 5]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements is true about Python's `OrderedDict` from the `collections` module?", "options": {"A": "It maintains the order of insertion", "B": "It does not maintain the order of insertion", "C": "It sorts the keys alphabetically", "D": "It sorts the keys numerically"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a bug with mutable default arguments?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def add_to_list(val, lst=[]):\n    lst.append(val)\n    return lst\n\nlist1 = add_to_list(1)\nlist2 = add_to_list(2)\nlist3 = add_to_list(3, [])\nprint(list1)\nprint(list2)\nprint(list3)</code></pre></div>", "options": {"A": "[1, 2]\n[1, 2]\n[3]", "B": "[1]\n[2]\n[3]", "C": "[1, 2]\n[1, 2, 3]\n[3]", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `defaultdict` class in Python?", "options": {"A": "It provides a default value for non-existing keys", "B": "It sorts the dictionary by keys", "C": "It merges two dictionaries", "D": "It converts a dictionary to a list"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the result of the following code involving the `Counter` class from the `collections` module?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from collections import Counter\n\ncounter = Counter(['a', 'b', 'c', 'a', 'b', 'a'])\nprint(counter.most_common(2))</code></pre></div>", "options": {"A": "[('a', 3), ('b', 2)]", "B": "[('a', 2), ('b', 2)]", "C": "[('b', 2), ('c', 1)]", "D": "[('a', 3), ('c', 1)]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving depth-first search (DFS) in a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>graph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F', 'G'],\n    'D': [],\n    'E': ['F'],\n    'F': [],\n    'G': []\n}\n\nvisited = set()\n\ndef dfs(node):\n    if node not in visited:\n        print(node, end=' ')\n        visited.add(node)\n        for neighbour in graph[node]:\n            dfs(neighbour)\n\ndfs('A')</code></pre></div>", "options": {"A": "A B D E F C G", "B": "A C G F B E D", "C": "A B E F D C G", "D": "A B C D E F G"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving breadth-first search (BFS) in a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from collections import deque\n\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F', 'G'],\n    'D': [],\n    'E': ['F'],\n    'F': [],\n    'G': []\n}\n\nvisited = set()\nqueue = deque(['A'])\n\nwhile queue:\n    node = queue.popleft()\n    if node not in visited:\n        print(node, end=' ')\n        visited.add(node)\n        queue.extend(graph[node])</code></pre></div>", "options": {"A": "A B C D E F G", "B": "A C G F B E D", "C": "A B D E F C G", "D": "A B E F D C G"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the result of the following code involving a circular buffer?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class CircularBuffer:\n    def __init__(self, size):\n        self.size = size\n        self.buffer = [None] * size\n        self.start = 0\n        self.end = 0\n        self.count = 0\n\n    def append(self, item):\n        self.buffer[self.end] = item\n        self.end = (self.end + 1) % self.size\n        if self.count == self.size:\n            self.start = (self.start + 1) % self.size\n        else:\n            self.count += 1\n\n    def get(self):\n        items = []\n        for i in range(self.count):\n            items.append(self.buffer[(self.start + i) % self.size])\n        return items\n\ncb = CircularBuffer(3)\ncb.append(1)\ncb.append(2)\ncb.append(3)\ncb.append(4)\nprint(cb.get())</code></pre></div>", "options": {"A": "[2, 3, 4]", "B": "[1, 2, 3]", "C": "[3, 4, 1]", "D": "[4, 1, 2]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `namedtuple` class in Python?", "options": {"A": "It creates tuple subclasses with named fields", "B": "It creates a dictionary with named fields", "C": "It creates a list with named fields", "D": "It creates a set with named fields"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Increasing Subsequence (LIS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lis(arr):\n    n = len(arr)\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    return max(lis)\n\narr = [10, 22, 9, 33, 21, 50, 41, 60, 80]\nprint(lis(arr))</code></pre></div>", "options": {"A": "6", "B": "5", "C": "7", "D": "4"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving detecting a cycle in a linked list?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef hasCycle(head):\n    slow = head\n    fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n\nhead = ListNode(3)\nhead.next = ListNode(2)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(-4)\nhead.next.next.next.next = head.next\nprint(hasCycle(head))</code></pre></div>", "options": {"A": "True", "B": "False", "C": "Error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving finding the maximum sum subarray using Kadane's Algorithm?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def max_subarray_sum(arr):\n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\narr = [-2, -3, 4, -1, -2, 1, 5, -3]\nprint(max_subarray_sum(arr))</code></pre></div>", "options": {"A": "7", "B": "6", "C": "5", "D": "4"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Knuth-Morris-Pratt (KMP) pattern matching algorithm?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def kmp_pattern_search(text, pattern):\n    def compute_lps(pattern):\n        lps = [0] * len(pattern)\n        length = 0\n        i = 1\n        while i < len(pattern):\n            if pattern[i] == pattern[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n        return lps\n\n    lps = compute_lps(pattern)\n    i = j = 0\n    while i < len(text):\n        if pattern[j] == text[i]:\n            i += 1\n            j += 1\n        if j == len(pattern):\n            return i - j\n        elif i < len(text) and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return -1\n\ntext = "abxabcabcaby"\npattern = "abcaby"\nprint(kmp_pattern_search(text, pattern))</code></pre></div>", "options": {"A": "6", "B": "5", "C": "7", "D": "8"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Bellman-Ford algorithm for finding shortest paths in a graph with negative weights?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def add_edge(self, u, v, w):\n        self.graph.append([u, v, w])\n\n    def bellman_ford(self, src):\n        dist = [float("Inf")] * self.V\n        dist[src] = 0\n        for _ in range(self.V - 1):\n            for u, v, w in self.graph:\n                if dist[u] != float("Inf") and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n        for u, v, w in self.graph:\n            if dist[u] != float("Inf") and dist[u] + w < dist[v]:\n                print("Graph contains negative weight cycle")\n                return\n        return dist\n\ng = Graph(5)\ng.add_edge(0, 1, -1)\ng.add_edge(0, 2, 4)\ng.add_edge(1, 2, 3)\ng.add_edge(1, 3, 2)\ng.add_edge(1, 4, 2)\ng.add_edge(3, 2, 5)\ng.add_edge(3, 1, 1)\ng.add_edge(4, 3, -3)\ndistances = g.bellman_ford(0)\nprint(distances)</code></pre></div>", "options": {"A": "[0, -1, 2, -2, 1]", "B": "[0, -1, 4, -2, 1]", "C": "[0, -1, 2, -2, -3]", "D": "Graph contains negative weight cycle"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following algorithms is used to find the minimum spanning tree of a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def prim_mst(graph):\n    # Implementation of Prim's algorithm\n    pass</code></pre></div>", "options": {"A": "Prim's Algorithm", "B": "Kruskal's Algorithm", "C": "Dijkstra's Algorithm", "D": "Both A and B"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Floyd-Warshall algorithm for finding shortest paths between all pairs of vertices?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>INF = float("inf")\n\ndef floyd_warshall(graph):\n    V = len(graph)\n    dist = list(map(lambda i: list(map(lambda j: j, i)), graph))\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ngraph = [[0, 5, INF, 10],\n         [INF, 0, 3, INF],\n         [INF, INF, 0, 1],\n         [INF, INF, INF, 0]]\n\nprint(floyd_warshall(graph))</code></pre></div>", "options": {"A": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, INF, 0, 1], [INF, INF, INF, 0]]", "B": "[[0, 5, 8, 10], [INF, 0, 3, 1], [INF, INF, 0, 1], [INF, INF, INF, 0]]", "C": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, INF, 0, 10], [INF, INF, INF, 0]]", "D": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, 5, 0, 1], [INF, INF, INF, 0]]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following sorting algorithms has the best average-case time complexity?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def quicksort(arr):\n    # Implementation of Quick Sort algorithm\n    pass</code></pre></div>", "options": {"A": "Merge Sort", "B": "Heap Sort", "C": "Quick Sort", "D": "Insertion Sort"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving finding the longest common subsequence (LCS) using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lcs(X, Y):\n    m = len(X)\n    n = len(Y)\n    L = [[0] * (n + 1) for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n    return L[m][n]\n\nX = "AGGTAB"\nY = "GXTXAYB"\nprint(lcs(X, Y))</code></pre></div>", "options": {"A": "4", "B": "5", "C": "6", "D": "7"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving Dijkstra's algorithm for finding the shortest path in a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import heapq\n\ndef dijkstra(graph, start):\n    pq = [(0, start)]\n    dist = {start: 0}\n    while pq:\n        current_dist, current_vertex = heapq.heappop(pq)\n        if current_dist > dist[current_vertex]:\n            continue\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_dist + weight\n            if distance < dist.get(neighbor, float("inf")):\n                dist[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return dist\n\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\nprint(dijkstra(graph, 'A'))</code></pre></div>", "options": {"A": "{'A': 0, 'B': 1, 'C': 3, 'D': 4}", "B": "{'A': 0, 'B': 1, 'C': 4, 'D': 6}", "C": "{'A': 0, 'B': 2, 'C': 3, 'D': 4}", "D": "{'A': 0, 'B': 1, 'C': 2, 'D': 3}"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following data structures is used to implement a LIFO queue?", "options": {"A": "Stack", "B": "Queue", "C": "Heap", "D": "Tree"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `namedtuple` from the `collections` module?", "options": {"A": "It creates a tuple subclass with named fields", "B": "It creates a dictionary subclass with named fields", "C": "It creates a list subclass with named fields", "D": "It creates a set subclass with named fields"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the A* search algorithm for finding the shortest path in a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import heapq\n\ndef heuristic(a, b):\n    return abs(a - b)\n\ndef a_star(graph, start, goal):\n    pq = [(0, start)]\n    came_from = {start: None}\n    cost_so_far = {start: 0}\n    while pq:\n        current = heapq.heappop(pq)[1]\n        if current == goal:\n            break\n        for next in graph[current]:\n            new_cost = cost_so_far[current] + graph[current][next]\n            if next not in cost_so_far or new_cost < cost_so_far[next]:\n                cost_so_far[next] = new_cost\n                priority = new_cost + heuristic(goal, next)\n                heapq.heappush(pq, (priority, next))\n                came_from[next] = current\n    return came_from, cost_so_far\n\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\nstart, goal = 'A', 'D'\ncame_from, cost_so_far = a_star(graph, start, goal)\nprint(cost_so_far[goal])</code></pre></div>", "options": {"A": "4", "B": "5", "C": "6", "D": "7"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the N-Queens problem using backtracking?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def is_safe(board, row, col):\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    for i, j in zip(range(row, len(board), 1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    return True\n\ndef solve_nqueens(board, col):\n    if col >= len(board):\n        return True\n    for i in range(len(board)):\n        if is_safe(board, i, col):\n            board[i][col] = 1\n            if solve_nqueens(board, col + 1):\n                return True\n            board[i][col] = 0\n    return False\n\nN = 4\nboard = [[0 for _ in range(N)] for _ in range(N)]\nsolve_nqueens(board, 0)\nfor row in board:\n    print(row)</code></pre></div>", "options": {"A": "[[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]", "B": "[[1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0]]", "C": "[[0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]", "D": "[[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 0]]"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `heapq` module in Python?", "options": {"A": "It provides functions for implementing a heap queue", "B": "It provides functions for implementing a priority queue", "C": "It provides functions for implementing a stack", "D": "Both A and B"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the 0/1 Knapsack problem using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def knapsack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i-1] <= w:\n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w])\n            else:\n                K[i][w] = K[i-1][w]\n    return K[n][W]\n\nval = [60, 100, 120]\nwt = [10, 20, 30]\nW = 50\nn = len(val)\nprint(knapsack(W, wt, val, n))</code></pre></div>", "options": {"A": "220", "B": "180", "C": "240", "D": "200"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Palindromic Subsequence (LPS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lps(seq):\n    n = len(seq)\n    L = [[0 for x in range(n)] for y in range(n)]\n    for i in range(n):\n        L[i][i] = 1\n    for cl in range(2, n+1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if seq[i] == seq[j] and cl == 2:\n                L[i][j] = 2\n            elif seq[i] == seq[j]:\n                L[i][j] = L[i + 1][j - 1] + 2\n            else:\n                L[i][j] = max(L[i][j - 1], L[i + 1][j])\n    return L[0][n - 1]\n\nseq = "BBABCBCAB"\nprint(lps(seq))</code></pre></div>", "options": {"A": "7", "B": "5", "C": "9", "D": "8"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Coin Change problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def coin_change(coins, m, V):\n    table = [0 for i in range(V + 1)]\n    table[0] = 1\n    for i in range(0, m):\n        for j in range(coins[i], V + 1):\n            table[j] += table[j - coins[i]]\n    return table[V]\n\ncoins = [1, 2, 3]\nV = 4\nm = len(coins)\nprint(coin_change(coins, m, V))</code></pre></div>", "options": {"A": "4", "B": "3", "C": "2", "D": "5"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following algorithms is used to find the shortest path between all pairs of vertices in a graph?", "options": {"A": "Dijkstra's Algorithm", "B": "Floyd-Warshall Algorithm", "C": "Bellman-Ford Algorithm", "D": "A* Algorithm"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Edit Distance problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def edit_distance(str1, str2, m, n):\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\n    return dp[m][n]\n\nstr1 = "sunday"\nstr2 = "saturday"\nm = len(str1)\nn = len(str2)\nprint(edit_distance(str1, str2, m, n))</code></pre></div>", "options": {"A": "3", "B": "5", "C": "7", "D": "6"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following sorting algorithms is not comparison-based?", "options": {"A": "Merge Sort", "B": "Heap Sort", "C": "Radix Sort", "D": "Quick Sort"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Rod Cutting problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def rod_cutting(price, n):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_val = float('-inf')\n        for j in range(i):\n            max_val = max(max_val, price[j] + dp[i - j - 1])\n        dp[i] = max_val\n    return dp[n]\n\nprice = [1, 5, 8, 9, 10, 17, 17, 20]\nn = len(price)\nprint(rod_cutting(price, n))</code></pre></div>", "options": {"A": "22", "B": "24", "C": "23", "D": "20"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Matrix Chain Multiplication problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def matrix_chain_order(p):\n    n = len(p) - 1\n    m = [[0 for x in range(n)] for x in range(n)]\n    for l in range(2, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            m[i][j] = float('inf')\n            for k in range(i, j):\n                q = m[i][k] + m[k+1][j] + p[i]*p[k+1]*p[j+1]\n                if q < m[i][j]:\n                    m[i][j] = q\n    return m[0][n-1]\n\np = [1, 2, 3, 4]\nprint(matrix_chain_order(p))</code></pre></div>", "options": {"A": "18", "B": "20", "C": "24", "D": "22"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Subset Sum problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def is_subset_sum(arr, n, sum):\n    dp = [[False for x in range(sum + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][sum]\n\narr = [3, 34, 4, 12, 5, 2]\nsum = 9\nn = len(arr)\nprint(is_subset_sum(arr, n, sum))</code></pre></div>", "options": {"A": "True", "B": "False", "C": "Error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following data structures is used to implement a FIFO queue?", "options": {"A": "Stack", "B": "Queue", "C": "Heap", "D": "Tree"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Increasing Subsequence (LIS) problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\narr = [10, 22, 9, 33, 21, 50, 41, 60, 80]\nprint(lis(arr))</code></pre></div>", "options": {"A": "6", "B": "5", "C": "7", "D": "8"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `deque` data structure from the `collections` module?", "options": {"A": "It supports O(1) operations for append and pop", "B": "It supports O(n) operations for append and pop", "C": "It is implemented as a singly linked list", "D": "It is implemented as a binary heap"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Ford-Fulkerson algorithm for finding the maximum flow in a flow network?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n\n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for ind, val in enumerate(self.graph[u]):\n                if visited[ind] == False and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return True if visited[t] else False\n\n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n        while self.bfs(source, sink, parent):\n            path_flow = float("Inf")\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n            max_flow += path_flow\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n        return max_flow\n\ngraph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]]\ng = Graph(graph)\nsource = 0\nsink = 5\nprint(g.ford_fulkerson(source, sink))</code></pre></div>", "options": {"A": "23", "B": "24", "C": "20", "D": "19"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `defaultdict` from the `collections` module?", "options": {"A": "It provides a default value for non-existing keys", "B": "It sorts the dictionary by keys", "C": "It merges two dictionaries", "D": "It converts a dictionary to a list"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Tarjan's Algorithm for finding Strongly Connected Components (SCCs) in a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n        self.Time = 0\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def SCCUtil(self, u, low, disc, stack_member, st):\n        disc[u] = self.Time\n        low[u] = self.Time\n        self.Time += 1\n        stack_member[u] = True\n        st.append(u)\n        for v in self.graph[u]:\n            if disc[v] == -1:\n                self.SCCUtil(v, low, disc, stack_member, st)\n                low[u] = min(low[u], low[v])\n            elif stack_member[v] == True:\n                low[u] = min(low[u], disc[v])\n        w = -1\n        if low[u] == disc[u]:\n            while w != u:\n                w = st.pop()\n                print(w, end=' ')\n                stack_member[w] = False\n            print()\n\n    def SCC(self):\n        disc = [-1] * self.V\n        low = [-1] * self.V\n        stack_member = [False] * self.V\n        st = []\n        for i in range(self.V):\n            if disc[i] == -1:\n                self.SCCUtil(i, low, disc, stack_member, st)\n\ng = Graph(5)\ng.add_edge(1, 0)\ng.add_edge(0, 2)\ng.add_edge(2, 1)\ng.add_edge(0, 3)\ng.add_edge(3, 4)\ng.SCC()</code></pre></div>", "options": {"A": "0 2 1\n3\n4", "B": "1 2 0\n4\n3", "C": "2 1 0\n3\n4", "D": "0 1 2\n4\n3"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Prim's Algorithm for finding the Minimum Spanning Tree (MST) of a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import sys\n\nclass Graph():\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]\n\n    def print_mst(self, parent):\n        print("Edge \tWeight")\n        for i in range(1, self.V):\n            print(parent[i], "-", i, "\t", self.graph[i][parent[i]])\n\n    def min_key(self, key, mst_set):\n        min = sys.maxsize\n        for v in range(self.V):\n            if key[v] < min and mst_set[v] == False:\n                min = key[v]\n                min_index = v\n        return min_index\n\n    def prim_mst(self):\n        key = [sys.maxsize] * self.V\n        parent = [None] * self.V\n        key[0] = 0\n        mst_set = [False] * self.V\n        parent[0] = -1\n        for cout in range(self.V):\n            u = self.min_key(key, mst_set)\n            mst_set[u] = True\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and mst_set[v] == False and key[v] > self.graph[u][v]:\n                    key[v] = self.graph[u][v]\n                    parent[v] = u\n        self.print_mst(parent)\n\ng = Graph(5)\ng.graph = [[0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0]]\ng.prim_mst()</code></pre></div>", "options": {"A": "0 - 1 \t 2\n1 - 2 \t 3\n0 - 3 \t 6\n1 - 4 \t 5", "B": "0 - 1 \t 2\n1 - 2 \t 3\n2 - 4 \t 7\n3 - 4 \t 9", "C": "0 - 1 \t 2\n1 - 3 \t 8\n1 - 4 \t 5\n0 - 2 \t 3", "D": "0 - 1 \t 2\n1 - 2 \t 3\n2 - 3 \t 7\n3 - 4 \t 9"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `Counter` from the `collections` module?", "options": {"A": "It counts the frequency of elements in a list", "B": "It creates a set with named fields", "C": "It sorts the elements by frequency", "D": "It merges two dictionaries"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Johnson's Algorithm for finding shortest paths between all pairs of vertices in a sparse graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from collections import defaultdict\nimport heapq\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append((v, w))\n\n    def bellman_ford(self, src):\n        dist = [float("Inf")] * self.V\n        dist[src] = 0\n        for _ in range(self.V - 1):\n            for u in range(self.V):\n                for v, w in self.graph[u]:\n                    if dist[u] != float("Inf") and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return dist\n\n    def dijkstra(self, src):\n        pq = [(0, src)]\n        dist = [float("Inf")] * self.V\n        dist[src] = 0\n        while pq:\n            d, u = heapq.heappop(pq)\n            for v, w in self.graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n\n    def johnson(self):\n        new_graph = Graph(self.V + 1)\n        for u in range(self.V):\n            for v, w in self.graph[u]:\n                new_graph.add_edge(u, v, w)\n        for u in range(self.V):\n            new_graph.add_edge(self.V, u, 0)\n        h = new_graph.bellman_ford(self.V)\n        for u in range(self.V):\n            for i in range(len(self.graph[u])):\n                v, w = self.graph[u][i]\n                self.graph[u][i] = (v, w + h[u] - h[v])\n        dist = []\n        for u in range(self.V):\n            dist.append(self.dijkstra(u))\n        return dist\n\ng = Graph(4)\ng.add_edge(0, 1, -5)\ng.add_edge(0, 2, 3)\ng.add_edge(1, 2, 2)\ng.add_edge(2, 3, 4)\ndistances = g.johnson()\nprint(distances)</code></pre></div>", "options": {"A": "[[0, -5, -2, 2], [float('Inf'), 0, 2, 6], [float('Inf'), float('Inf'), 0, 4], [float('Inf'), float('Inf'), float('Inf'), 0]]", "B": "[[0, -5, 3, 7], [float('Inf'), 0, 2, 6], [float('Inf'), float('Inf'), 0, 4], [float('Inf'), float('Inf'), float('Inf'), 0]]", "C": "[[0, -5, -2, 2], [float('Inf'), 0, 2, 6], [float('Inf'), float('Inf'), 0, 4], [float('Inf'), float('Inf'), float('Inf'), float('Inf')]]", "D": "[[0, -5, 2, 6], [float('Inf'), 0, 2, 5], [float('Inf'), float('Inf'), 0, 4], [float('Inf'), float('Inf'), float('Inf'), 0]]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Minimum Cost Path problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def min_cost(cost, m, n):\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    dp[0][0] = cost[0][0]\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n    return dp[m][n]\n\ncost = [[1, 2, 3], [4, 8, 2], [1, 5, 3]]\nm, n = 2, 2\nprint(min_cost(cost, m, n))</code></pre></div>", "options": {"A": "8", "B": "11", "C": "9", "D": "7"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Kruskal's Algorithm for finding the Minimum Spanning Tree (MST) of a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def add_edge(self, u, v, w):\n        self.graph.append([u, v, w])\n\n    def find(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.find(parent, parent[i])\n\n    def union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    def kruskal_mst(self):\n        result = []\n        i = 0\n        e = 0\n        self.graph = sorted(self.graph, key=lambda item: item[2])\n        parent = []\n        rank = []\n        for node in range(self.V):\n            parent.append(node)\n            rank.append(0)\n        while e < self.V - 1:\n            u, v, w = self.graph[i]\n            i += 1\n            x = self.find(parent, u)\n            y = self.find(parent, v)\n            if x != y:\n                e += 1\n                result.append([u, v, w])\n                self.union(parent, rank, x, y)\n        minimum_cost = 0\n        for u, v, weight in result:\n            minimum_cost += weight\n        return minimum_cost\n\ng = Graph(4)\ng.add_edge(0, 1, 10)\ng.add_edge(0, 2, 6)\ng.add_edge(0, 3, 5)\ng.add_edge(1, 3, 15)\ng.add_edge(2, 3, 4)\nprint(g.kruskal_mst())</code></pre></div>", "options": {"A": "19", "B": "18", "C": "16", "D": "15"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `Counter` class in Python?", "options": {"A": "It counts the frequency of elements in a list", "B": "It merges two dictionaries", "C": "It converts a dictionary to a list", "D": "It sorts the dictionary by keys"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Hopcroft-Karp Algorithm for finding maximum matching in a bipartite graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from collections import deque\n\nclass BipartiteGraph:\n    def __init__(self, u, v):\n        self.U = u\n        self.V = v\n        self.graph = [[0 for _ in range(v)] for _ in range(u)]\n        self.pairU = [-1] * u\n        self.pairV = [-1] * v\n        self.dist = [-1] * u\n\n    def bfs(self):\n        queue = deque()\n        for u in range(self.U):\n            if self.pairU[u] == -1:\n                self.dist[u] = 0\n                queue.append(u)\n            else:\n                self.dist[u] = float('inf')\n        found = False\n        while queue:\n            u = queue.popleft()\n            if self.dist[u] < float('inf'):\n                for v in range(self.V):\n                    if self.graph[u][v] and (self.pairV[v] == -1 or self.dist[self.pairV[v]] == float('inf')):\n                        self.dist[self.pairV[v]] = self.dist[u] + 1\n                        queue.append(self.pairV[v])\n                        found = True\n        return found\n\n    def dfs(self, u):\n        if u != -1:\n            for v in range(self.V):\n                if self.graph[u][v] and (self.pairV[v] == -1 or (self.dist[self.pairV[v]] == self.dist[u] + 1 and self.dfs(self.pairV[v]))):\n                    self.pairV[v] = u\n                    self.pairU[u] = v\n                    return True\n            self.dist[u] = float('inf')\n            return False\n        return True\n\n    def hopcroft_karp(self):\n        matching = 0\n        while self.bfs():\n            for u in range(self.U):\n                if self.pairU[u] == -1 and self.dfs(u):\n                    matching += 1\n        return matching\n\nbg = BipartiteGraph(4, 4)\nbg.graph = [[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 0], [0, 1, 1, 0]]\nprint(bg.hopcroft_karp())</code></pre></div>", "options": {"A": "3", "B": "2", "C": "4", "D": "5"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@staticmethod` decorator in Python?", "options": {"A": "It defines a method that does not operate on an instance or class", "B": "It defines a method that operates on an instance", "C": "It defines a method that operates on a class", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@classmethod` decorator in Python?", "options": {"A": "It defines a method that operates on a class", "B": "It defines a method that operates on an instance", "C": "It defines a method that operates on neither an instance nor a class", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements is true about Python's `@property` decorator?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def __init__(self, value):\n        self._value = value\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, new_value):\n        self._value = new_value\n\nobj = MyClass(10)\nprint(obj.value)\nobj.value = 20\nprint(obj.value)</code></pre></div>", "options": {"A": "It defines a method as a property", "B": "It allows the method to be accessed as an attribute", "C": "It allows the method to be set as an attribute", "D": "All of the above"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving closures?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def outer(x):\n    def inner(y):\n        return x + y\n    return inner\n\nadd_five = outer(5)\nresult = add_five(10)\nprint(result)</code></pre></div>", "options": {"A": "15", "B": "10", "C": "5", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a closure with mutable default arguments?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def outer(lst=[]):\n    def inner(val):\n        lst.append(val)\n        return lst\n    return inner\n\nclosure = outer()\nprint(closure(1))\nprint(closure(2))\nnew_closure = outer()\nprint(new_closure(3))</code></pre></div>", "options": {"A": "[1]\n[1, 2]\n[3]", "B": "[1]\n[1, 2]\n[1, 2, 3]", "C": "[1]\n[2]\n[3]", "D": "[1, 2]\n[3]\n[1, 2, 3]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a decorator?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def my_decorator(func):\n    def wrapper():\n        print('Something is happening before the function is called.')\n        func()\n        print('Something is happening after the function is called.')\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print('Hello!')\n\nsay_hello()</code></pre></div>", "options": {"A": "Something is happening before the function is called.\nHello!", "B": "Something is happening before the function is called.\nHello!\nSomething is happening after the function is called.", "C": "Hello!\nSomething is happening after the function is called.", "D": "Hello!"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving recursive functions?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(5))</code></pre></div>", "options": {"A": "120", "B": "24", "C": "6", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for calculating Fibonacci numbers?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def fibonacci(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 2:\n        return 1\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]\n\nprint(fibonacci(10))</code></pre></div>", "options": {"A": "55", "B": "89", "C": "144", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving recursive backtracking for solving the N-Queens problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def is_safe(board, row, col):\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    for i, j in zip(range(row, len(board), 1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    return True\n\ndef solve_nqueens(board, col):\n    if col >= len(board):\n        return True\n    for i in range(len(board)):\n        if is_safe(board, i, col):\n            board[i][col] = 1\n            if solve_nqueens(board, col + 1):\n                return True\n            board[i][col] = 0\n    return False\n\nN = 4\nboard = [[0 for _ in range(N)] for _ in range(N)]\nsolve_nqueens(board, 0)\nfor row in board:\n    print(row)</code></pre></div>", "options": {"A": "[[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]", "B": "[[1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0]]", "C": "[[0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]", "D": "[[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 0]]"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `functools` module in Python?", "options": {"A": "It provides higher-order functions", "B": "It provides functions for functional programming", "C": "It provides decorators to manipulate or extend the behavior of functions", "D": "All of the above"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving memoization for calculating the factorial of a number?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def factorial(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 1\n    else:\n        memo[n] = n * factorial(n-1, memo)\n        return memo[n]\n\nprint(factorial(5))</code></pre></div>", "options": {"A": "120", "B": "24", "C": "6", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Increasing Subsequence (LIS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lis(arr):\n    n = len(arr)\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    return max(lis)\n\narr = [10, 22, 9, 33, 21, 50, 41, 60, 80]\nprint(lis(arr))</code></pre></div>", "options": {"A": "6", "B": "5", "C": "7", "D": "4"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@wraps` decorator from the `functools` module?", "options": {"A": "It preserves the original function's metadata", "B": "It modifies the original function's metadata", "C": "It adds new metadata to the original function", "D": "It removes metadata from the original function"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a recursive solution for finding the GCD of two numbers?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\nprint(gcd(48, 18))</code></pre></div>", "options": {"A": "6", "B": "12", "C": "18", "D": "24"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `partial` function in Python's `functools` module?", "options": {"A": "It allows partial application of a function", "B": "It modifies the original function's arguments", "C": "It creates a new function with some arguments fixed", "D": "Both A and C"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `lru_cache` decorator in Python's `functools` module?", "options": {"A": "It provides a least-recently-used cache", "B": "It provides a most-recently-used cache", "C": "It provides a fixed-size cache", "D": "It provides an unlimited cache"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@total_ordering` decorator from the `functools` module?", "options": {"A": "It generates all comparison methods from `__eq__` and one other comparison method", "B": "It generates only the `__lt__` and `__eq__` methods", "C": "It generates all comparison methods from `__lt__` and `__eq__`", "D": "It generates all comparison methods from `__eq__` and two other comparison methods"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@dataclass` decorator?", "options": {"A": "It generates special methods like `__init__` and `__repr__` for the class", "B": "It generates only the `__init__` method for the class", "C": "It generates only the `__repr__` method for the class", "D": "It generates special methods like `__init__` and `__str__` for the class"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the `@lru_cache` decorator?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=3)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(5))\nprint(fib(4))\nprint(fib.cache_info())</code></pre></div>", "options": {"A": "5, 3, CacheInfo(hits=3, misses=5, maxsize=3, currsize=3)", "B": "5, 3, CacheInfo(hits=5, misses=3, maxsize=3, currsize=3)", "C": "5, 3, CacheInfo(hits=5, misses=5, maxsize=3, currsize=3)", "D": "5, 3, CacheInfo(hits=3, misses=3, maxsize=3, currsize=3)"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@singledispatch` decorator in Python's `functools` module?", "options": {"A": "It allows function overloading based on the type of the first argument", "B": "It allows function overloading based on the number of arguments", "C": "It allows function overloading based on the return type", "D": "It allows function overloading based on the types of all arguments"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements is true about Python's `@contextmanager` decorator from the `contextlib` module?", "options": {"A": "It allows a function to be used as a context manager", "B": "It allows a class to be used as a context manager", "C": "It generates a context manager from a generator function", "D": "Both A and C"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@dataclass` decorator?", "options": {"A": "It generates special methods like `__init__` and `__repr__` for the class", "B": "It generates only the `__init__` method for the class", "C": "It generates only the `__repr__` method for the class", "D": "It generates special methods like `__init__` and `__str__` for the class"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@dataclass` decorator?", "options": {"A": "It generates special methods like `__init__` and `__repr__` for the class", "B": "It generates only the `__init__` method for the class", "C": "It generates only the `__repr__` method for the class", "D": "It generates special methods like `__init__` and `__str__` for the class"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What will be the output of the following code involving a generator function?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def count_up_to(max):\n    count = 1\n    while count <= max:\n        yield count\n        count += 1\n\ncounter = count_up_to(5)\nprint(next(counter))\nprint(next(counter))\nprint(next(counter))</code></pre></div>", "options": {"A": "1\n2\n3", "B": "1\n2\n3\n4\n5", "C": "1\n1\n1", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving nested decorators?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def decorator1(func):\n    def wrapper():\n        print('Decorator 1')\n        func()\n    return wrapper\n\ndef decorator2(func):\n    def wrapper():\n        print('Decorator 2')\n        func()\n    return wrapper\n\n@decorator1\n@decorator2\ndef say_hello():\n    print('Hello!')\n\nsay_hello()</code></pre></div>", "options": {"A": "Decorator 1\nDecorator 2\nHello!", "B": "Decorator 2\nDecorator 1\nHello!", "C": "Hello!\nDecorator 1\nDecorator 2", "D": "Decorator 1\nHello!\nDecorator 2"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@abstractmethod` decorator in Python's `abc` module?", "options": {"A": "It marks a method as abstract", "B": "It marks a method as static", "C": "It marks a method as final", "D": "It marks a method as protected"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Common Subsequence (LCS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lcs(X, Y):\n    m = len(X)\n    n = len(Y)\n    L = [[0] * (n + 1) for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n    return L[m][n]\n\nX = "AGGTAB"\nY = "GXTXAYB"\nprint(lcs(X, Y))</code></pre></div>", "options": {"A": "4", "B": "5", "C": "6", "D": "7"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@dataclass` decorator in Python?", "options": {"A": "It automatically generates special methods like `__init__` and `__repr__` for the class", "B": "It marks a class as abstract", "C": "It creates a namedtuple subclass", "D": "It defines a class as a singleton"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@property` decorator in Python?", "options": {"A": "It defines a method as a property", "B": "It allows a method to be accessed as an attribute", "C": "It allows a method to be set as an attribute", "D": "All of the above"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following statements is true about Python's `@staticmethod` decorator?", "options": {"A": "It defines a method that does not operate on an instance or class", "B": "It defines a method that operates on an instance", "C": "It defines a method that operates on a class", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@classmethod` decorator in Python?", "options": {"A": "It defines a method that operates on a class", "B": "It defines a method that operates on an instance", "C": "It defines a method that operates on neither an instance nor a class", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving decorators and closures?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Before calling', func.__name__)\n        result = func(*args, **kwargs)\n        print('After calling', func.__name__)\n        return result\n    return wrapper\n\n@decorator\ndef add(a, b):\n    return a + b\n\nprint(add(3, 4))</code></pre></div>", "options": {"A": "Before calling add\nAfter calling add\n7", "B": "Before calling add\n7\nAfter calling add", "C": "7\nBefore calling add\nAfter calling add", "D": "7"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What does the `@staticmethod` decorator do in Python?", "options": {"A": "It defines a method that doesn't access instance or class attributes.", "B": "It defines a method that accesses instance attributes.", "C": "It defines a method that accesses class attributes.", "D": "None of the above."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What does the `@classmethod` decorator do in Python?", "options": {"A": "It defines a method that operates on the class.", "B": "It defines a method that operates on an instance.", "C": "It defines a method that doesn't access instance or class attributes.", "D": "None of the above."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@property` decorator in Python?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class MyClass:\n    def __init__(self, value):\n        self._value = value\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, new_value):\n        self._value = new_value\n\nobj = MyClass(10)\nprint(obj.value)\nobj.value = 20\nprint(obj.value)</code></pre></div>", "options": {"A": "It defines a method as a property.", "B": "It allows the method to be accessed as an attribute.", "C": "It allows the method to be set as an attribute.", "D": "All of the above."}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving closures?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def make_multiplier_of(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\nmult3 = make_multiplier_of(3)\nmult5 = make_multiplier_of(5)\nprint(mult3(9))\nprint(mult5(3))\nprint(mult3(mult5(2)))</code></pre></div>", "options": {"A": "27\n15\n30", "B": "27\n15\n90", "C": "9\n15\n6", "D": "Error"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a decorator?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Before function call')\n        result = func(*args, **kwargs)\n        print('After function call')\n        return result\n    return wrapper\n\n@my_decorator\ndef add(a, b):\n    return a + b\n\nprint(add(3, 4))</code></pre></div>", "options": {"A": "Before function call\nAfter function call\n7", "B": "Before function call\n7\nAfter function call", "C": "7\nBefore function call\nAfter function call", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving recursive functions?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(5))</code></pre></div>", "options": {"A": "120", "B": "24", "C": "6", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for calculating Fibonacci numbers?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(10))</code></pre></div>", "options": {"A": "55", "B": "89", "C": "144", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving recursive backtracking for solving the N-Queens problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def is_safe(board, row, col):\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    for i, j in zip(range(row, len(board), 1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    return True\n\ndef solve_nqueens(board, col):\n    if col >= len(board):\n        return True\n    for i in range(len(board)):\n        if is_safe(board, i, col):\n            board[i][col] = 1\n            if solve_nqueens(board, col + 1):\n                return True\n            board[i][col] = 0\n    return False\n\nN = 4\nboard = [[0 for _ in range(N)] for _ in range(N)]\nsolve_nqueens(board, 0)\nfor row in board:\n    print(row)</code></pre></div>", "options": {"A": "[[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]", "B": "[[1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0]]", "C": "[[0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]", "D": "[[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 0]]"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `functools` module in Python?", "options": {"A": "It provides higher-order functions.", "B": "It provides functions for functional programming.", "C": "It provides decorators to manipulate or extend the behavior of functions.", "D": "All of the above."}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What does the `@wraps` decorator do in Python's `functools` module?", "options": {"A": "It preserves the original function's metadata.", "B": "It modifies the original function's metadata.", "C": "It adds new metadata to the original function.", "D": "It removes metadata from the original function."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `partial` function in Python's `functools` module?", "options": {"A": "It allows partial application of a function.", "B": "It modifies the original function's arguments.", "C": "It creates a new function with some arguments fixed.", "D": "Both A and C."}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What does the `@lru_cache` decorator do in Python's `functools` module?", "options": {"A": "It provides a least-recently-used cache.", "B": "It provides a most-recently-used cache.", "C": "It provides a fixed-size cache.", "D": "It provides an unlimited cache."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@singledispatch` decorator in Python's `functools` module?", "options": {"A": "It allows function overloading based on the type of the first argument.", "B": "It allows function overloading based on the number of arguments.", "C": "It allows function overloading based on the return type.", "D": "It allows function overloading based on the types of all arguments."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@contextmanager` decorator in Python's `contextlib` module?", "options": {"A": "It allows a function to be used as a context manager.", "B": "It allows a class to be used as a context manager.", "C": "It generates a context manager from a generator function.", "D": "Both A and C."}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving recursive functions and memoization?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def memoize_factorial(f):\n    memo = {}\n    def helper(x):\n        if x not in memo:            \n            memo[x] = f(x)\n        return memo[x]\n    return helper\n\n@memoize_factorial\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(5))\nprint(factorial(6))</code></pre></div>", "options": {"A": "120\n720", "B": "120\n144", "C": "720\n5040", "D": "Error"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming and the Knapsack problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def knapsack(weights, values, W):\n    n = len(values)\n    dp = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                dp[i][w] = 0\n            elif weights[i-1] <= w:\n                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])\n            else:\n                dp[i][w] = dp[i-1][w]\n    return dp[n][W]\n\nvalues = [60, 100, 120]\nweights = [10, 20, 30]\nW = 50\nprint(knapsack(weights, values, W))</code></pre></div>", "options": {"A": "220", "B": "180", "C": "240", "D": "200"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@total_ordering` decorator in the `functools` module?", "options": {"A": "It generates all comparison methods from `__eq__` and one other comparison method.", "B": "It generates only the `__lt__` and `__eq__` methods.", "C": "It generates all comparison methods from `__lt__` and `__eq__`.", "D": "It generates all comparison methods from `__eq__` and two other comparison methods."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@dataclass` decorator?", "options": {"A": "It generates special methods like `__init__` and `__repr__` for the class.", "B": "It generates only the `__init__` method for the class.", "C": "It generates only the `__repr__` method for the class.", "D": "It generates special methods like `__init__` and `__str__` for the class."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving nested decorators?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def decorator1(func):\n    def wrapper(*args, **kwargs):\n        print('Decorator 1')\n        return func(*args, **kwargs)\n    return wrapper\n\ndef decorator2(func):\n    def wrapper(*args, **kwargs):\n        print('Decorator 2')\n        return func(*args, **kwargs)\n    return wrapper\n\n@decorator1\n@decorator2\ndef say_hello():\n    print('Hello!')\n\nsay_hello()</code></pre></div>", "options": {"A": "Decorator 1\nDecorator 2\nHello!", "B": "Decorator 2\nDecorator 1\nHello!", "C": "Hello!\nDecorator 1\nDecorator 2", "D": "Decorator 1\nHello!\nDecorator 2"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving a closure with mutable default arguments?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def outer(lst=[]):\n    def inner(val):\n        lst.append(val)\n        return lst\n    return inner\n\nclosure = outer()\nprint(closure(1))\nprint(closure(2))\nnew_closure = outer()\nprint(new_closure(3))</code></pre></div>", "options": {"A": "[1]\n[1, 2]\n[3]", "B": "[1]\n[1, 2]\n[1, 2, 3]", "C": "[1]\n[2]\n[3]", "D": "[1, 2]\n[3]\n[1, 2, 3]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the Rod Cutting problem using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def rod_cutting(price, n):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_val = float('-inf')\n        for j in range(i):\n            max_val = max(max_val, price[j] + dp[i - j - 1])\n        dp[i] = max_val\n    return dp[n]\n\nprice = [1, 5, 8, 9, 10, 17, 17, 20]\nn = len(price)\nprint(rod_cutting(price, n))</code></pre></div>", "options": {"A": "22", "B": "24", "C": "23", "D": "20"}, "correct_answers": ["B"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the Coin Change problem using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def coin_change(coins, m, V):\n    table = [0 for i in range(V + 1)]\n    table[0] = 1\n    for i in range(0, m):\n        for j in range(coins[i], V + 1):\n            table[j] += table[j - coins[i]]\n    return table[V]\n\ncoins = [1, 2, 3]\nV = 4\nm = len(coins)\nprint(coin_change(coins, m, V))</code></pre></div>", "options": {"A": "4", "B": "3", "C": "2", "D": "5"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Palindromic Subsequence (LPS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lps(seq):\n    n = len(seq)\n    L = [[0 for x in range(n)] for y in range(n)]\n    for i in range(n):\n        L[i][i] = 1\n    for cl in range(2, n+1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if seq[i] == seq[j] and cl == 2:\n                L[i][j] = 2\n            elif seq[i] == seq[j]:\n                L[i][j] = L[i + 1][j - 1] + 2\n            else:\n                L[i][j] = max(L[i][j - 1], L[i + 1][j])\n    return L[0][n - 1]\n\nseq = "BBABCBCAB"\nprint(lps(seq))</code></pre></div>", "options": {"A": "7", "B": "5", "C": "9", "D": "8"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the Edit Distance problem using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def edit_distance(str1, str2, m, n):\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\n    return dp[m][n]\n\nstr1 = "sunday"\nstr2 = "saturday"\nm = len(str1)\nn = len(str2)\nprint(edit_distance(str1, str2, m, n))</code></pre></div>", "options": {"A": "3", "B": "5", "C": "7", "D": "6"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What does the `@abstractmethod` decorator do in Python's `abc` module?", "options": {"A": "It marks a method as abstract.", "B": "It marks a method as static.", "C": "It marks a method as final.", "D": "It marks a method as protected."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@total_ordering` decorator in Python's `functools` module?", "options": {"A": "It generates all comparison methods from `__eq__` and one other comparison method.", "B": "It generates only the `__lt__` and `__eq__` methods.", "C": "It generates all comparison methods from `__lt__` and `__eq__`.", "D": "It generates all comparison methods from `__eq__` and two other comparison methods."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Bellman-Ford algorithm for finding shortest paths in a graph with negative weights?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def add_edge(self, u, v, w):\n        self.graph.append([u, v, w])\n\n    def bellman_ford(self, src):\n        dist = [float("Inf")] * self.V\n        dist[src] = 0\n        for _ in range(self.V - 1):\n            for u, v, w in self.graph:\n                if dist[u] != float("Inf") and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n        for u, v, w in self.graph:\n            if dist[u] != float("Inf") and dist[u] + w < dist[v]:\n                print("Graph contains negative weight cycle")\n                return\n        return dist\n\ng = Graph(5)\ng.add_edge(0, 1, -1)\ng.add_edge(0, 2, 4)\ng.add_edge(1, 2, 3)\ng.add_edge(1, 3, 2)\ng.add_edge(1, 4, 2)\ng.add_edge(3, 2, 5)\ng.add_edge(3, 1, 1)\ng.add_edge(4, 3, -3)\ndistances = g.bellman_ford(0)\nprint(distances)</code></pre></div>", "options": {"A": "[0, -1, 2, -2, 1]", "B": "[0, -1, 4, -2, 1]", "C": "[0, -1, 2, -2, -3]", "D": "Graph contains negative weight cycle"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Floyd-Warshall algorithm for finding shortest paths between all pairs of vertices?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>INF = float("inf")\n\ndef floyd_warshall(graph):\n    V = len(graph)\n    dist = list(map(lambda i: list(map(lambda j: j, i)), graph))\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ngraph = [[0, 5, INF, 10],\n         [INF, 0, 3, INF],\n         [INF, INF, 0, 1],\n         [INF, INF, INF, 0]]\n\nprint(floyd_warshall(graph))</code></pre></div>", "options": {"A": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, INF, 0, 1], [INF, INF, INF, 0]]", "B": "[[0, 5, 8, 10], [INF, 0, 3, 1], [INF, INF, 0, 1], [INF, INF, INF, 0]]", "C": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, INF, 0, 10], [INF, INF, INF, 0]]", "D": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, 5, 0, 1], [INF, INF, INF, 0]]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@wraps` decorator from the `functools` module?", "options": {"A": "It preserves the original function's metadata.", "B": "It modifies the original function's metadata.", "C": "It adds new metadata to the original function.", "D": "It removes metadata from the original function."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the 0/1 Knapsack problem using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def knapsack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i-1] <= w:\n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w])\n            else:\n                K[i][w] = K[i-1][w]\n    return K[n][W]\n\nval = [60, 100, 120]\nwt = [10, 20, 30]\nW = 50\nn = len(val)\nprint(knapsack(W, wt, val, n))</code></pre></div>", "options": {"A": "220", "B": "180", "C": "240", "D": "200"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following algorithms is used to find the minimum spanning tree of a graph?", "options": {"A": "Prim's Algorithm", "B": "Kruskal's Algorithm", "C": "Dijkstra's Algorithm", "D": "Both A and B"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Increasing Subsequence (LIS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\narr = [10, 22, 9, 33, 21, 50, 41, 60, 80]\nprint(lis(arr))</code></pre></div>", "options": {"A": "6", "B": "5", "C": "7", "D": "8"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the Subset Sum problem using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def is_subset_sum(arr, n, sum):\n    dp = [[False for x in range(sum + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][sum]\n\narr = [3, 34, 4, 12, 5, 2]\nsum = 9\nn = len(arr)\nprint(is_subset_sum(arr, n, sum))</code></pre></div>", "options": {"A": "True", "B": "False", "C": "Error", "D": "None of the above"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following sorting algorithms is not comparison-based?", "options": {"A": "Merge Sort", "B": "Heap Sort", "C": "Radix Sort", "D": "Quick Sort"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "Which of the following is true about Python's `@contextmanager` decorator from the `contextlib` module?", "options": {"A": "It allows a function to be used as a context manager.", "B": "It allows a class to be used as a context manager.", "C": "It generates a context manager from a generator function.", "D": "Both A and C."}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the purpose of the `@dataclass` decorator in Python?", "options": {"A": "It automatically generates special methods like `__init__` and `__repr__` for the class.", "B": "It marks a class as abstract.", "C": "It creates a namedtuple subclass.", "D": "It defines a class as a singleton."}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Matrix Chain Multiplication problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def matrix_chain_order(p):\n    n = len(p) - 1\n    m = [[0 for x in range(n)] for x in range(n)]\n    for l in range(2, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            m[i][j] = float('inf')\n            for k in range(i, j):\n                q = m[i][k] + m[k+1][j] + p[i]*p[k+1]*p[j+1]\n                if q < m[i][j]:\n                    m[i][j] = q\n    return m[0][n-1]\n\np = [1, 2, 3, 4]\nprint(matrix_chain_order(p))</code></pre></div>", "options": {"A": "18", "B": "20", "C": "24", "D": "22"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving Depth-First Search (DFS) in a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def dfs_util(self, v, visited):\n        visited[v] = True\n        print(v, end=' ')\n        for i in self.graph[v]:\n            if not visited[i]:\n                self.dfs_util(i, visited)\n\n    def dfs(self, v):\n        visited = [False] * self.V\n        self.dfs_util(v, visited)\n\ng = Graph(4)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\ng.dfs(2)</code></pre></div>", "options": {"A": "2 0 1 3", "B": "2 3 0 1", "C": "2 0 3 1", "D": "2 1 3 0"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving Breadth-First Search (BFS) in a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def bfs(self, s):\n        visited = [False] * (max(self.graph) + 1)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            s = queue.pop(0)\n            print(s, end=' ')\n            for i in self.graph[s]:\n                if not visited[i]:\n                    queue.append(i)\n                    visited[i] = True\n\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\ng.bfs(2)</code></pre></div>", "options": {"A": "2 0 3 1", "B": "2 3 0 1", "C": "2 1 3 0", "D": "2 0 1 3"}, "correct_answers": ["D"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving Dijkstra's algorithm for finding the shortest path in a graph?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import heapq\n\ndef dijkstra(graph, start):\n    pq = [(0, start)]\n    dist = {start: 0}\n    while pq:\n        current_dist, current_vertex = heapq.heappop(pq)\n        if current_dist > dist[current_vertex]:\n            continue\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_dist + weight\n            if distance < dist.get(neighbor, float("inf")):\n                dist[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return dist\n\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\nprint(dijkstra(graph, 'A'))</code></pre></div>", "options": {"A": "{'A': 0, 'B': 1, 'C': 3, 'D': 4}", "B": "{'A': 0, 'B': 1, 'C': 4, 'D': 6}", "C": "{'A': 0, 'B': 2, 'C': 3, 'D': 4}", "D": "{'A': 0, 'B': 1, 'C': 2, 'D': 3}"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving the Floyd-Warshall algorithm for finding shortest paths between all pairs of vertices?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>INF = float("inf")\n\ndef floyd_warshall(graph):\n    V = len(graph)\n    dist = list(map(lambda i: list(map(lambda j: j, i)), graph))\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ngraph = [[0, 5, INF, 10],\n         [INF, 0, 3, INF],\n         [INF, INF, 0, 1],\n         [INF, INF, INF, 0]]\n\nprint(floyd_warshall(graph))</code></pre></div>", "options": {"A": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, INF, 0, 1], [INF, INF, INF, 0]]", "B": "[[0, 5, 8, 10], [INF, 0, 3, 1], [INF, INF, 0, 1], [INF, INF, INF, 0]]", "C": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, INF, 0, 10], [INF, INF, INF, 0]]", "D": "[[0, 5, 8, 9], [INF, 0, 3, 4], [INF, 5, 0, 1], [INF, INF, INF, 0]]"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Increasing Subsequence (LIS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\narr = [10, 22, 9, 33, 21, 50, 41, 60, 80]\nprint(lis(arr))</code></pre></div>", "options": {"A": "6", "B": "5", "C": "7", "D": "8"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the 0/1 Knapsack problem using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def knapsack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i-1] <= w:\n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w])\n            else:\n                K[i][w] = K[i-1][w]\n    return K[n][W]\n\nval = [60, 100, 120]\nwt = [10, 20, 30]\nW = 50\nn = len(val)\nprint(knapsack(W, wt, val, n))</code></pre></div>", "options": {"A": "220", "B": "180", "C": "240", "D": "200"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving solving the Coin Change problem using dynamic programming?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def coin_change(coins, m, V):\n    table = [0 for i in range(V + 1)]\n    table[0] = 1\n    for i in range(0, m):\n        for j in range(coins[i], V + 1):\n            table[j] += table[j - coins[i]]\n    return table[V]\n\ncoins = [1, 2, 3]\nV = 4\nm = len(coins)\nprint(coin_change(coins, m, V))</code></pre></div>", "options": {"A": "4", "B": "3", "C": "2", "D": "5"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Longest Palindromic Subsequence (LPS)?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lps(seq):\n    n = len(seq)\n    L = [[0 for x in range(n)] for y in range(n)]\n    for i in range(n):\n        L[i][i] = 1\n    for cl in range(2, n+1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if seq[i] == seq[j] and cl == 2:\n                L[i][j] = 2\n            elif seq[i] == seq[j]:\n                L[i][j] = L[i + 1][j - 1] + 2\n            else:\n                L[i][j] = max(L[i][j - 1], L[i + 1][j])\n    return L[0][n - 1]\n\nseq = "BBABCBCAB"\nprint(lps(seq))</code></pre></div>", "options": {"A": "7", "B": "5", "C": "9", "D": "8"}, "correct_answers": ["A"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What will be the output of the following code involving dynamic programming for the Matrix Chain Multiplication problem?\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def matrix_chain_order(p):\n    n = len(p) - 1\n    m = [[0 for x in range(n)] for x in range(n)]\n    for l in range(2, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            m[i][j] = float('inf')\n            for k in range(i, j):\n                q = m[i][k] + m[k+1][j] + p[i]*p[k+1]*p[j+1]\n                if q < m[i][j]:\n                    m[i][j] = q\n    return m[0][n-1]\n\np = [1, 2, 3, 4]\nprint(matrix_chain_order(p))</code></pre></div>", "options": {"A": "18", "B": "20", "C": "24", "D": "22"}, "correct_answers": ["C"], "is_multiple_choice": false}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "How does the Depth-First Search (DFS) algorithm work in a graph? Explain with code and memory usage.", "options": {"A": "DFS starts at the root node and explores as far as possible along each branch before backtracking.", "B": "DFS starts at the root node and explores all neighbors at the present depth prior to moving on to nodes at the next depth level.", "C": "DFS uses a queue to keep track of the next node to visit.", "D": "DFS is not suitable for traversing graphs."}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>class Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def dfs_util(self, v, visited):\n        visited[v] = True\n        print(v, end=' ')\n        for i in self.graph[v]:\n            if not visited[i]:\n                self.dfs_util(i, visited)\n\n    def dfs(self, v):\n        visited = [False] * self.V\n        self.dfs_util(v, visited)\n\ng = Graph(4)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\ng.dfs(2)</code></pre></div>\n\n**Memory Usage:** The memory usage of DFS is O(V), where V is the number of vertices. This is due to the stack used for recursion in DFS."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "How does the Breadth-First Search (BFS) algorithm work in a graph? Explain with code and memory usage.", "options": {"A": "BFS starts at the root node and explores as far as possible along each branch before backtracking.", "B": "BFS starts at the root node and explores all neighbors at the present depth prior to moving on to nodes at the next depth level.", "C": "BFS uses a stack to keep track of the next node to visit.", "D": "BFS is not suitable for traversing graphs."}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or an arbitrary node in the case of a graph) and explores all neighbors at the present depth prior to moving on to nodes at the next depth level. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def bfs(self, s):\n        visited = [False] * (max(self.graph) + 1)\n        queue = deque([s])\n        visited[s] = True\n        while queue:\n            s = queue.popleft()\n            print(s, end=' ')\n            for i in self.graph[s]:\n                if not visited[i]:\n                    queue.append(i)\n                    visited[i] = True\n\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\ng.bfs(2)</code></pre></div>\n\n**Memory Usage:** The memory usage of BFS is O(V), where V is the number of vertices, due to the queue used for storing the nodes."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "How does Dijkstra's algorithm work for finding the shortest path in a graph? Explain with code and memory usage.", "options": {"A": "Dijkstra's algorithm finds the shortest path between nodes in a graph by using a priority queue.", "B": "Dijkstra's algorithm finds the shortest path between nodes in a graph by using a stack.", "C": "Dijkstra's algorithm is only suitable for unweighted graphs.", "D": "Dijkstra's algorithm is used for finding the maximum path in a graph."}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "Dijkstra's algorithm is used to find the shortest paths between nodes in a graph, which may represent, for example, road networks. It uses a priority queue to efficiently select the closest node that has not been processed yet. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>import heapq\n\ndef dijkstra(graph, start):\n    pq = [(0, start)]\n    dist = {start: 0}\n    while pq:\n        current_dist, current_vertex = heapq.heappop(pq)\n        if current_dist > dist[current_vertex]:\n            continue\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_dist + weight\n            if distance < dist.get(neighbor, float('inf')):\n                dist[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return dist\n\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\nprint(dijkstra(graph, 'A'))</code></pre></div>\n\n**Memory Usage:** The memory usage of Dijkstra's algorithm is O(V + E log V), where V is the number of vertices and E is the number of edges. This is due to the priority queue and the graph representation."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "How does the A* search algorithm work for finding the shortest path in a graph? Explain with code and memory usage.", "options": {"A": "A* search algorithm combines the advantages of Dijkstra's algorithm and BFS.", "B": "A* search algorithm uses a stack to keep track of the next node to visit.", "C": "A* search algorithm is not suitable for weighted graphs.", "D": "A* search algorithm only works on unweighted graphs."}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The A* search algorithm finds the shortest path between nodes in a weighted graph by using both the actual cost from the start and a heuristic estimated cost to the goal. It uses a priority queue to prioritize nodes to be explored based on their combined actual and heuristic costs. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>from heapq import heappush, heappop\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n        self.weights = {}\n\n    def add_edge(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        self.edges[from_node].append(to_node)\n        self.weights[(from_node, to_node)] = weight\n\n    def a_star(self, start, goal, h):\n        open_list = [(0, start)]\n        came_from = {start: None}\n        g_score = {start: 0}\n        f_score = {start: h(start)}\n        while open_list:\n            current = heappop(open_list)[1]\n            if current == goal:\n                path = []\n                while current:\n                    path.append(current)\n                    current = came_from[current]\n                return path[::-1]\n            for neighbor in self.edges.get(current, []):\n                tentative_g_score = g_score[current] + self.weights[(current, neighbor)]\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + h(neighbor)\n                    heappush(open_list, (f_score[neighbor], neighbor))\n        return None\n\ndef heuristic(node):\n    h = {'A': 10, 'B': 8, 'C': 5, 'D': 7, 'E': 3, 'F': 6, 'G': 5, 'H': 3, 'I': 1, 'J': 0}\n    return h[node]\n\ng = Graph()\ng.add_edge('A', 'B', 1)\ng.add_edge('A', 'C', 4)\ng.add_edge('B', 'D', 2)\ng.add_edge('C', 'D', 1)\ng.add_edge('B', 'E', 5)\ng.add_edge('D', 'E', 3)\ng.add_edge('D', 'F', 1)\ng.add_edge('E', 'G', 2)\ng.add_edge('F', 'H', 4)\ng.add_edge('G', 'I', 1)\ng.add_edge('H', 'I', 2)\ng.add_edge('I', 'J', 3)\nprint(g.a_star('A', 'J', heuristic))</code></pre></div>\n\n**Memory Usage:** The memory usage of A* algorithm is O(V), where V is the number of vertices, due to the priority queue and the heuristic function."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "How does the Longest Common Subsequence (LCS) algorithm work using dynamic programming? Explain with code and memory usage.", "options": {"A": "LCS finds the longest subsequence common to all sequences using a 2D table to store results of subproblems.", "B": "LCS finds the shortest subsequence common to all sequences using a 1D array to store results of subproblems.", "C": "LCS is a greedy algorithm.", "D": "LCS does not use dynamic programming."}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The Longest Common Subsequence (LCS) problem is to find the longest subsequence common to all sequences in a set of sequences. It uses dynamic programming to store the results of subproblems in a 2D table. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lcs(X, Y, m, n):\n    L = [[None]*(n+1) for i in range(m+1)]\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n    return L[m][n]\n\nX = "AGGTAB"\nY = "GXTXAYB"\nm = len(X)\nn = len(Y)\nprint(lcs(X, Y, m, n))</code></pre></div>\n\n**Memory Usage:** The memory usage of the LCS algorithm is O(m*n), where m and n are the lengths of the input sequences. This is due to the 2D table used to store the results of subproblems." "is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "How does the Longest Increasing Subsequence (LIS) algorithm work using dynamic programming? Explain with code and memory usage.", "options": {"A": "LIS finds the longest increasing subsequence using a 1D array to store results of subproblems.", "B": "LIS finds the longest decreasing subsequence using a 1D array to store results of subproblems.", "C": "LIS uses a greedy approach.", "D": "LIS does not use dynamic programming."}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The Longest Increasing Subsequence (LIS) problem is to find the longest subsequence of a sequence such that all elements of the subsequence are sorted in increasing order. It uses dynamic programming to store the results of subproblems in a 1D array. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def lis(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum\n\narr = [10, 22, 9, 33, 21, 50, 41, 60, 80]\nprint(lis(arr))</code></pre></div>\n\n**Memory Usage:** The memory usage of the LIS algorithm is O(n), where n is the length of the input sequence. This is due to the 1D array used to store the results of subproblems."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "How does the Knapsack problem algorithm work using dynamic programming? Explain with code and memory usage.", "options": {"A": "The Knapsack problem is solved using a 2D table to store results of subproblems.", "B": "The Knapsack problem is solved using a 1D array to store results of subproblems.", "C": "The Knapsack problem is a greedy algorithm.", "D": "The Knapsack problem does not use dynamic programming."}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The Knapsack problem involves selecting a subset of items to maximize the total value without exceeding the weight capacity. It uses dynamic programming to store the results of subproblems in a 2D table. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def knapsack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i-1] <= w:\n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w])\n            else:\n                K[i][w] = K[i-1][w]\n    return K[n][W]\n\nval = [60, 100, 120]\nwt = [10, 20, 30]\nW = 50\nn = len(val)\nprint(knapsack(W, wt, val, n))</code></pre></div>\n\n**Memory Usage:** The memory usage of the Knapsack problem algorithm is O(n*W), where n is the number of items and W is the weight capacity. This is due to the 2D table used to store the results of subproblems."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "How does the Edit Distance algorithm work using dynamic programming? Explain with code and memory usage.", "options": {"A": "Edit Distance finds the minimum number of operations required to convert one string into another using a 2D table to store results of subproblems.", "B": "Edit Distance finds the maximum number of operations required to convert one string into another using a 1D array to store results of subproblems.", "C": "Edit Distance uses a greedy approach.", "D": "Edit Distance does not use dynamic programming."}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The Edit Distance problem involves finding the minimum number of operations (insertions, deletions, or substitutions) required to convert one string into another. It uses dynamic programming to store the results of subproblems in a 2D table. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def edit_distance(str1, str2, m, n):\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\n    return dp[m][n]\n\nstr1 = "sunday"\nstr2 = "saturday"\nm = len(str1)\nn = len(str2)\nprint(edit_distance(str1, str2, m, n))</code></pre></div>\n\n**Memory Usage:** The memory usage of the Edit Distance algorithm is O(m*n), where m and n are the lengths of the input strings. This is due to the 2D table used to store the results of subproblems.","is_multiple_choice": false}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "How does the Coin Change problem algorithm work using dynamic programming? Explain with code and memory usage.", "options": {"A": "The Coin Change problem is solved using a 1D array to store results of subproblems.", "B": "The Coin Change problem is solved using a 2D table to store results of subproblems.", "C": "The Coin Change problem uses a greedy approach.", "D": "The Coin Change problem does not use dynamic programming."}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The Coin Change problem involves finding the minimum number of coins needed to make a given amount. It uses dynamic programming to store the results of subproblems in a 1D array. Here's the code and explanation:\n\n<div style='border:1px solid black; padding:10px;'><pre><code>def coin_change(coins, m, V):\n    table = [0 for i in range(V + 1)]\n    table[0] = 1\n    for i in range(0, m):\n        for j in range(coins[i], V + 1):\n            table[j] += table[j - coins[i]]\n    return table[V]\n\ncoins = [1, 2, 3]\nV = 4\nm = len(coins)\nprint(coin_change(coins, m, V))</code></pre></div>\n\n**Memory Usage:** The memory usage of the Coin Change problem algorithm is O(V), where V is the total amount. This is due to the 1D array used to store the results of subproblems."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of a simple for loop that runs from 0 to n-1?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "A simple for loop that runs from 0 to n-1 has a time complexity of O(n) because it iterates n times."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of nested for loops where the outer loop runs from 0 to n-1 and the inner loop runs from 0 to m-1?", "options": {"A": "O(n + m)", "B": "O(n * m)", "C": "O(n^2)", "D": "O(m^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of nested for loops where the outer loop runs from 0 to n-1 and the inner loop runs from 0 to m-1 is O(n * m) because the inner loop runs m times for each iteration of the outer loop."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the space complexity of creating a list with n elements in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of creating a list with n elements is O(n) because it requires space to store n elements."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of a while loop that halves the value of n until it reaches 1?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["D"], "is_multiple_choice": false, "explanation": "A while loop that halves the value of n until it reaches 1 has a time complexity of O(log n) because it takes log n iterations to reduce n to 1."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of a recursive function that calls itself n times without any other operations?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a recursive function that calls itself n times without any other operations is O(n) because each call adds a new frame to the call stack."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of binary search in a sorted list of n elements?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["D"], "is_multiple_choice": false, "explanation": "The time complexity of binary search in a sorted list of n elements is O(log n) because it repeatedly divides the search interval in half."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of merge sort?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of merge sort is O(n) because it requires additional space to store the temporary arrays used for merging."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the average-case time complexity of quick sort?", "options": {"A": "O(1)", "B": "O(n log n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The average-case time complexity of quick sort is O(n log n) because it divides the list into two halves and sorts them recursively."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of depth-first search (DFS) in a graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(e)", "D": "O(n + e)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of depth-first search (DFS) in a graph with n vertices and e edges is O(n) because it requires space to store the visited nodes and the call stack in the worst case."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of breadth-first search (BFS) in a graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e)", "D": "O(e)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The time complexity of breadth-first search (BFS) in a graph with n vertices and e edges is O(n + e) because it processes each vertex and edge once."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the space complexity of a linked list with n elements?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a linked list with n elements is O(n) because it requires space to store n elements."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of accessing an element in a list by index?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of accessing an element in a list by index is O(1) because it directly accesses the memory location."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of inserting an element at the beginning of a list?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of inserting an element at the beginning of a list is O(n) because it requires shifting all the elements one position to the right."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of appending an element to the end of a list?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of appending an element to the end of a list is O(1) because it directly adds the element to the end of the list."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the space complexity of a dictionary with n key-value pairs in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a dictionary with n key-value pairs in Python is O(n) because it requires space to store n key-value pairs."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of inserting an element into a dictionary in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of inserting an element into a dictionary in Python is O(1) because it uses a hash table for fast lookups and insertions."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of deleting an element from a dictionary in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of deleting an element from a dictionary in Python is O(1) because it uses a hash table for fast deletions."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the space complexity of a set with n elements in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a set with n elements in Python is O(n) because it requires space to store n elements."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of adding an element to a set in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of adding an element to a set in Python is O(1) because it uses a hash table for fast insertions."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of removing an element from a set in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of removing an element from a set in Python is O(1) because it uses a hash table for fast deletions."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the time complexity of accessing an element in a tuple by index?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of accessing an element in a tuple by index is O(1) because it directly accesses the memory location."}
{"skill": "Python", "difficulty": "easy", "type": "multiple_choice", "question": "What is the space complexity of a tuple with n elements?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a tuple with n elements is O(n) because it requires space to store n elements."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of slicing a list in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of slicing a list in Python is O(k) where k is the length of the slice because it creates a new list with the sliced elements."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of slicing a list in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of slicing a list in Python is O(k) where k is the length of the slice because it creates a new list with the sliced elements."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of concatenating two strings in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of concatenating two strings in Python is O(n) where n is the total length of the strings because it creates a new string with the combined length."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of concatenating two strings in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of concatenating two strings in Python is O(n) where n is the total length of the strings because it creates a new string with the combined length."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of reversing a string in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of reversing a string in Python is O(n) where n is the length of the string because it processes each character once."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of reversing a string in Python?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of reversing a string in Python is O(n) where n is the length of the string because it creates a new string with the reversed characters."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of inserting an element in a sorted list using binary search?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of inserting an element in a sorted list using binary search is O(n) because although the binary search takes O(log n) time, inserting the element requires shifting elements which takes O(n) time."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of a recursive function that calls itself n times with a single recursive call in each call?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a recursive function that calls itself n times with a single recursive call in each call is O(n) because each call adds a new frame to the call stack."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of the quicksort algorithm in the worst case?", "options": {"A": "O(1)", "B": "O(n log n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The time complexity of the quicksort algorithm in the worst case is O(n^2) because it can degenerate into a simple bubble sort if the pivot selection is poor."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of the mergesort algorithm?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of the mergesort algorithm is O(n) because it requires additional space for the temporary arrays used during the merge process."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of accessing an element in a hash table (dictionary) in the average case?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of accessing an element in a hash table (dictionary) in the average case is O(1) because hash tables provide constant-time complexity for average-case lookups."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of inserting an element in a heap (priority queue)?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(log n)"}, "correct_answers": ["D"], "is_multiple_choice": false, "explanation": "The time complexity of inserting an element in a heap (priority queue) is O(log n) because it requires maintaining the heap property, which involves logarithmic time operations."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of a breadth-first search (BFS) in a graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e)", "D": "O(e)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The space complexity of a breadth-first search (BFS) in a graph with n vertices and e edges is O(n + e) because it requires space to store the queue of vertices and the visited list."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of finding the maximum element in an unsorted list of n elements?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of finding the maximum element in an unsorted list of n elements is O(n) because it requires iterating through the list once to find the maximum element."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of a depth-first search (DFS) using an iterative approach with an explicit stack in a graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e)", "D": "O(e)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a depth-first search (DFS) using an iterative approach with an explicit stack in a graph with n vertices and e edges is O(n) because the stack can grow to hold all the vertices in the worst case."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the Floyd-Warshall algorithm for finding the shortest paths between all pairs of vertices in a graph with n vertices?", "options": {"A": "O(1)", "B": "O(n log n)", "C": "O(n^3)", "D": "O(n^2)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The time complexity of the Floyd-Warshall algorithm for finding the shortest paths between all pairs of vertices in a graph with n vertices is O(n^3) because it involves three nested loops over the vertices."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of the Floyd-Warshall algorithm for finding the shortest paths between all pairs of vertices in a graph with n vertices?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(n^3)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The space complexity of the Floyd-Warshall algorithm for finding the shortest paths between all pairs of vertices in a graph with n vertices is O(n^2) because it requires a 2D array to store the shortest path distances between every pair of vertices."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the Bellman-Ford algorithm for finding the shortest path from a single source to all other vertices in a graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n log n)", "C": "O(n^2)", "D": "O(n * e)"}, "correct_answers": ["D"], "is_multiple_choice": false, "explanation": "The time complexity of the Bellman-Ford algorithm for finding the shortest path from a single source to all other vertices in a graph with n vertices and e edges is O(n * e) because it relaxes all edges up to n-1 times."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of Dijkstra's algorithm using a priority queue for finding the shortest path in a graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e log n)", "D": "O(e)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The space complexity of Dijkstra's algorithm using a priority queue for finding the shortest path in a graph with n vertices and e edges is O(n + e log n) because it requires space for the priority queue and the graph representation."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of inserting an element into a red-black tree?", "options": {"A": "O(1)", "B": "O(log n)", "C": "O(n)", "D": "O(n log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of inserting an element into a red-black tree is O(log n) because it is a balanced binary search tree and insertion involves maintaining the tree's balanced properties."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of a trie (prefix tree) storing n keys with an average length of k?", "options": {"A": "O(n)", "B": "O(n * k)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a trie (prefix tree) storing n keys with an average length of k is O(n * k) because each node in the trie represents a character and the trie can have up to n * k nodes."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the KMP (Knuth-Morris-Pratt) algorithm for pattern matching?", "options": {"A": "O(n + m)", "B": "O(n * m)", "C": "O(n^2)", "D": "O(m^2)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The time complexity of the KMP (Knuth-Morris-Pratt) algorithm for pattern matching is O(n + m) where n is the length of the text and m is the length of the pattern because it preprocesses the pattern in O(m) time and searches the text in O(n) time."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of the KMP (Knuth-Morris-Pratt) algorithm for pattern matching?", "options": {"A": "O(1)", "B": "O(m)", "C": "O(n)", "D": "O(n + m)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of the KMP (Knuth-Morris-Pratt) algorithm for pattern matching is O(m) where m is the length of the pattern because it requires additional space to store the longest prefix suffix (LPS) array."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of deleting an element from a singly linked list?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of deleting an element from a singly linked list is O(n) because it requires traversing the list to find the element to delete."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of a stack implemented using a list with n elements?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of a stack implemented using a list with n elements is O(n) because it requires space to store n elements in the list."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of reversing a singly linked list?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of reversing a singly linked list is O(n) because it requires traversing the list once to reverse the links between the nodes."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of reversing a singly linked list?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The space complexity of reversing a singly linked list is O(1) because it requires only a constant amount of additional space for pointers."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of checking if a string is a palindrome?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of checking if a string is a palindrome is O(n) because it requires comparing each character from the start and end of the string."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of checking if a string is a palindrome?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n^2)", "D": "O(log n)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The space complexity of checking if a string is a palindrome is O(1) because it requires only a constant amount of additional space for pointers."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the Rabin-Karp algorithm for pattern matching in the average case?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + m)", "D": "O(n * m)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The time complexity of the Rabin-Karp algorithm for pattern matching in the average case is O(n + m) where n is the length of the text and m is the length of the pattern because it uses hashing to compare the pattern with substrings of the text."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of the Rabin-Karp algorithm for pattern matching?", "options": {"A": "O(1)", "B": "O(m)", "C": "O(n)", "D": "O(n + m)"}, "correct_answers": ["A"], "is_multiple_choice": false, "explanation": "The space complexity of the Rabin-Karp algorithm for pattern matching is O(1) because it uses only a constant amount of additional space for hashing and comparison operations."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the Boyer-Moore algorithm for pattern matching in the best case?", "options": {"A": "O(1)", "B": "O(n / m)", "C": "O(n + m)", "D": "O(n * m)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of the Boyer-Moore algorithm for pattern matching in the best case is O(n / m) where n is the length of the text and m is the length of the pattern because it can skip over large sections of the text when mismatches occur."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of the Boyer-Moore algorithm for pattern matching?", "options": {"A": "O(1)", "B": "O(m)", "C": "O(n)", "D": "O(n + m)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of the Boyer-Moore algorithm for pattern matching is O(m) where m is the length of the pattern because it requires additional space for the bad character and good suffix tables."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of checking if a binary tree is a valid binary search tree (BST)?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of checking if a binary tree is a valid binary search tree (BST) is O(n) because it requires traversing all the nodes of the tree once."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of checking if a binary tree is a valid binary search tree (BST)?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of checking if a binary tree is a valid binary search tree (BST) is O(n) because it requires space for the recursion stack in the worst case."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of finding the height of a binary tree?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of finding the height of a binary tree is O(n) because it requires traversing all the nodes of the tree once."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of finding the height of a binary tree?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of finding the height of a binary tree is O(n) because it requires space for the recursion stack in the worst case."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of performing a level-order traversal on a binary tree?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of performing a level-order traversal on a binary tree is O(n) because it requires visiting all the nodes of the tree once."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of performing a level-order traversal on a binary tree?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n log n)", "D": "O(n^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of performing a level-order traversal on a binary tree is O(n) because it requires space for the queue used to store the nodes at each level."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the Tarjan's algorithm for finding strongly connected components (SCCs) in a graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n + e)", "C": "O(n^2)", "D": "O(e^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of the Tarjan's algorithm for finding strongly connected components (SCCs) in a graph with n vertices and e edges is O(n + e) because it performs a DFS traversal of the graph."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of the Tarjan's algorithm for finding strongly connected components (SCCs) in a graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e)", "D": "O(e)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The space complexity of the Tarjan's algorithm for finding strongly connected components (SCCs) in a graph with n vertices and e edges is O(n) because it requires space to store the recursion stack, indices, and low-link values."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the Hopcroft-Karp algorithm for finding maximum matching in a bipartite graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n + e)", "C": "O(sqrt(n) * e)", "D": "O(e^2)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The time complexity of the Hopcroft-Karp algorithm for finding maximum matching in a bipartite graph with n vertices and e edges is O(sqrt(n) * e) because it uses a combination of BFS and DFS to find augmenting paths."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of the Hopcroft-Karp algorithm for finding maximum matching in a bipartite graph with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e)", "D": "O(e)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The space complexity of the Hopcroft-Karp algorithm for finding maximum matching in a bipartite graph with n vertices and e edges is O(n + e) because it requires space to store the graph representation, matching, and visited arrays."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the Ford-Fulkerson algorithm for finding the maximum flow in a flow network with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n + e)", "C": "O(max_flow * e)", "D": "O(e^2)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The time complexity of the Ford-Fulkerson algorithm for finding the maximum flow in a flow network with n vertices and e edges is O(max_flow * e) because it repeatedly augments the flow along augmenting paths."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of the Ford-Fulkerson algorithm for finding the maximum flow in a flow network with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e)", "D": "O(e)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The space complexity of the Ford-Fulkerson algorithm for finding the maximum flow in a flow network with n vertices and e edges is O(n + e) because it requires space to store the residual graph and visited array."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the time complexity of the Edmonds-Karp algorithm for finding the maximum flow in a flow network with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n + e)", "C": "O(n * e^2)", "D": "O(e^2)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The time complexity of the Edmonds-Karp algorithm for finding the maximum flow in a flow network with n vertices and e edges is O(n * e^2) because it repeatedly finds augmenting paths using BFS."}
{"skill": "Python", "difficulty": "hard", "type": "multiple_choice", "question": "What is the space complexity of the Edmonds-Karp algorithm for finding the maximum flow in a flow network with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e)", "D": "O(e)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The space complexity of the Edmonds-Karp algorithm for finding the maximum flow in a flow network with n vertices and e edges is O(n + e) because it requires space to store the residual graph and visited array."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the time complexity of performing a topological sort on a directed acyclic graph (DAG) with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n + e)", "C": "O(n^2)", "D": "O(e^2)"}, "correct_answers": ["B"], "is_multiple_choice": false, "explanation": "The time complexity of performing a topological sort on a directed acyclic graph (DAG) with n vertices and e edges is O(n + e) because it involves processing each vertex and edge once."}
{"skill": "Python", "difficulty": "medium", "type": "multiple_choice", "question": "What is the space complexity of performing a topological sort on a directed acyclic graph (DAG) with n vertices and e edges?", "options": {"A": "O(1)", "B": "O(n)", "C": "O(n + e)", "D": "O(e)"}, "correct_answers": ["C"], "is_multiple_choice": false, "explanation": "The space complexity of performing a topological sort on a directed acyclic graph (DAG) with n vertices and e edges is O(n + e) because it requires space to store the graph representation and the visited array."}